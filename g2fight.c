/* Copyright 1984-2007 David Fotland.  All rights reserved.
 * This source code is being distributed under a nondisclosure
 * agreement.  Do not distribute it without written permission
 * from David Fotland.  Do not show it to anyone not party to the
 * nondisclosure.  Maintain good security on any computers or
 * disks containing this source code.
 */
#include "g2hd.h"
#include "g2rldef.h"
#include "g2tree.h"
#include "g2fcache.h"
#include "g2sem.h"
#include "g2fight.h"
#include <stdio.h>
#include <time.h>
#ifdef WIN32
#include <windows.h>
#else
static int GetTickCount(void)
{
	return 1000 * time(NULL);
}
#endif
/* goals for fights */

# define F_WINSEM 0
# define F_KILLSEM 1
# define F_LIVE 2
# define F_STOPLIVE 3
# define F_KILL 4
# define F_STOPKILL 5

/* results for fights */

# define GOODWINS 0
# define BADWINS 1
# define LOSEFIGHT 2
# define GOODUNKNOWN 3
# define BADUNKNOWN 4
# define GOODLIKELY 5
# define BADLIKELY 6
# define LOSELIKELY 7
# define KORESULT 8

/* packing for probabilities in move lists */

/* keep probabilities in g2fight.c - routines that return lists
 * MV_MAKE takes a probability of failure (0 to 50)
 * containing proabilities should be static */

/* unfortunately, all move probabilities must be less than 64 so
 * that move+prob fits in a 16 bit signed int.
 * so proability range is 0-50.
 */
 
/* probability of living as a function of total eyes expected with this move
 * (armyeyespace + value)
 * adjust down for each successive move generated by adpot
 * adjust up if group has lots of other ways to live 
 */

# define MAXLIFE 41 
static int lifeprob[MAXLIFE] = 
{ 0,  
  1,  1,  1,  2,  2,  2,  2,  4, /* to 1 eye */
  8, 13, 16, 20, 24, 30, 35, 46, /* to 2 eyes */
 46, 47, 47, 48, 48, 48, 48, 49, /* to 3 eyes */
 49, 49, 49, 49, 49, 49, 49, 50,  /* to 4 eyes */
 50, 50, 50, 50, 50, 50, 50, 50,
};


int newrunval[NUMRUN] = {  /* how much extra run-pot expect to get if run here */
	/* indexed by the type of running point here */
	/* can't have high values for 7 or 8 since they can double count with extension */
	/* value for 3 is typically 3 or 4 in opening */
12, 11, 9, 7, 5, 4, 4, 2, 2, 2, 2, 2, 1, 0,
};



/* how many eyes to count for a particular armyrn_pot */

# define MAXRUNEYES 25
static int runeyes[MAXRUNEYES] = {
0,   
 1,  2,  4,  6,  7,  8,  9,  10, 11, 12, 13, 14,
14, 15, 15, 16, 18, 20, 22, 24, 26, 28, 30, 32,
};



# define NUMSEMMOVES 100
static sqr_t sem_moves[NUMSEMMOVES];
static int sem_val[NUMSEMMOVES];
static int savesemval[NUMSEMMOVES];
static int savesemmoves[NUMSEMMOVES];
static int savesemmptr;
static int mptr;
/*static void	semrun(army_t army, int val);   run army */
static int killeyeprob(army_t army, int peakeyes, int val, int count);
static int killrunprob(army_t army, int peakeyes, int val, int count, sqr_t s);

# define UNKNOWN 2

/* result of fight reading:
 * 5 - Wins
 * 4 - likely wins
 * 3 - ko
 * 2 - out of nodes or too deep
 * 1 - likely loses
 * 0 - loses
 */
 
int resvalue[9] = { 5, 0, 0, 2, 2, 4, 4, 1, 3 };
int oppvalue[] = { 5, 4, 2, 3, 1, 0 };

extern int numcmoves[4],ccl[3],numlifecalls,maxlifecalls[NUMLEVELS],numpotmoves[NUMLEVELS];
extern int maxsemdiff[NUMLEVELS];
extern int sumeyes[41];
extern int dirnm[4],opdir[4],msks[],livealive[NUMALIVE];
extern int semalive[NUMALIVE], semnbralive[NUMALIVE];
extern char maxfightdepth[NUMLEVELS];
extern int maxfightsize[NUMLEVELS];

extern int obaval;  /* value of taking a big gote point */
static int fightsize;  /* number of life calls in current fight */

# include "g2fight.pr"
static int getrunprob(army_t a, int val, int count);
static int geteyeprob(army_t a, int val, int maxval, int count);
  
/* return list of nearby groups that army can attack to try to make life */    
    
list_t weaksemneighbors(army_t army) {
	list_t grouplist = EOL,weakgrouplist = EOL,ptr;
	army_t a2;
	int min,typ,max,hemin,hemax,memin,memax,eyes,maxeyes,nbrcanrun,res;
	int amin,atyp,amax,ahemin,ahemax,amemin,amemax,stronggroupsem = FALSE;
	
	semeailibs(army,&amin,&atyp,&amax,&ahemin,&ahemax,&amemin,&amemax);
	
	if (armynbp[army] == EOL)getarmynbp(army);
	for (ptr = armynbp[army]; ptr != EOL; ptr = link[ptr]) {
		a2 = (army_t)list[ptr];
		if (A_ALIVE(a2) == SEKI)
			addlist(list[armygroups[list[ptr]]],&weakgrouplist);
		semeailibs(a2,&min,&max,&typ,&hemin,&hemax,&memin,&memax);
		if (A_THREATENED(a2) ||

			((A_ALIVE(a2) == MIAI || A_ALIVE(a2) == BARELY_ALIVE) &&
			  armyrn_pot[a2] <= 2 && min < 15 &&
			  (armyeyespace[a2]+armyrest[a2] <= 8 || armyeyespace[a2]+armysecond[a2] < 16)) ||

			 semnbralive[A_ALIVE(a2)] && min < 15 && 
			min <= amin+10 && ( typ <= atyp + 5 || typ <= 15  || min <= 4) &&
			(armyrn_pot[a2] <= SEMEAI_RUN || armylibs[a2] < 4) &&
			((res = semeai_result(army,a2)) <= 3 || res == 5 || res == 7) ) {

			eyes = armyeyespace[army] + eyesifcapture(a2,army,&maxeyes);
			if (eyes >= 16) {
				if (armyrn_pot[a2])nbrcanrun = TRUE;
				addlist(list[armygroups[list[ptr]]],&grouplist);  /* since reading breaks armies */
				if (semalive[A_ALIVE(a2)])
					stronggroupsem = TRUE;  /* need liberties to attack this group */  
			}
			else if (armyrn_pot[a2] >= LIMP_RUN || /* if capture, get out */
				maxeyes >= 16 || maxeyes >= 8 && A_THREATENED(a2) ||
				armyeyespace[army] + armybestpot[army] + maxeyes >= 16 ||
				armyrn_pot[a2] > 2 && A_THREATENED(a2))
				addlist(list[armygroups[list[ptr]]],&weakgrouplist);
		}
	}


	if (grouplist == EOL)
		return(weakgrouplist);
	if (stronggroupsem)
		mrglist(weakgrouplist,&grouplist);

	killist(&weakgrouplist);
	return(grouplist);
}
	
    
/* without reading, generate move suggestions to army by capturing
 * neighbor groups that are threatened or have fewer liberties
 */    
    
void save_capture_nbr(army_t army, list_t *slist, int defval) {
	int urg, i, size, val;
	int hisbest;  /* his best attack against me if I tenuki */
/*	int nbrcanrun = FALSE; */
	int myprob,hisprob;  /* probs of my winning fight after my or his move */
	group_t g = NOGROUP;
	list_t grouplist = EOL,/* weakgrouplist = EOL, */moves = EOL, ptr, mptr;

	urg = FALSE;
	size = 0;
	for (ptr = armygroups[army]; ptr != EOL; ptr = link[ptr])
		if (grsize[list[ptr]] > size) {
			g = (group_t)list[ptr];    /* save biggest group in army */
			size = grsize[g];
		}
	

	/* find neighboring groups to try to kill */
	grouplist = weaksemneighbors(army);
	
	if (defval > 320*16)defval = 320*16;
	if (urg)defval += 300;
                                      
	/* try to kill neighbors */
	for (ptr = grouplist; ptr != EOL; ptr = link[ptr]) {
		if (G_THREATENED(list[ptr])) {
			if (grcapmove[list[ptr]] != NOSQUARE &&
				/* grcapmove[list[ptr]] != kosquare && 1/1/99  generate ko recapture */
				grcapmove[list[ptr]] != PASS &&
				addlist(grcapmove[list[ptr]], slist))
				fire_strat_rule(grcapmove[list[ptr]], KILL_TO_SAVE,defval, G_KEYPOINT(g), armysize[list[ptr]] * 50);
			continue;
		}	
		moves = getsemeaimoves((group_t)list[ptr], g);
		killist(&moves);
		hisbest = savesemval[0];
		hisprob = winsemprob(army, G_ARMY(list[ptr]), 0, hisbest);
		moves = getsemeaimoves(g, (group_t)list[ptr]);
		for (mptr = moves, i = 0; mptr != EOL; mptr = link[mptr], i++) {
			if (MV_MV(list[mptr]) == PASS)
				continue;
			myprob = winsemprob(army, G_ARMY(list[ptr]), savesemval[i], 0);
			if (addlist(MV_MV(list[mptr]), slist)) {
				val = (((defval / 16) * (myprob - hisprob)) / 100) * 16;
				ASSERT(grlv[g]);
				fire_strat_rule(MV_MV(list[mptr]), KILL_TO_SAVE, val, G_KEYPOINT(g), armysize[list[ptr]]);
			}
		}
		killist(&moves);	
	}
	killist(&grouplist);
		
}
	


/* look at grouplist and find the weakest group to try to kill in semeai
 * weakest group has smallest typ semeailibs
 */

group_t weakestnbr(list_t grouplist)
{
	list_t ptr;
	group_t bestgroup = NOGROUP;
	int bestval = 0, minlibs, typlibs, maxlibs, hemin, hemax, memin, memax;
	for (ptr = grouplist; ptr != EOL; ptr = link[ptr]) {  /* first threatened groups */
		if (!grthreatened[list[ptr]] || 
			grcapmove[list[ptr]] == NOSQUARE 
			/* || grcapmove[list[ptr]] == kosquare 1/1/98 allow ko recapture */) {
			continue;
		}
		if (grsize[list[ptr]] > bestval) {
			bestval = grsize[list[ptr]];
			bestgroup = (group_t)list[ptr];
		}	
	}
	if (bestval != 0) {
		return bestgroup;
	}
	bestval = 10000;
	for (ptr = grouplist; ptr != EOL; ptr = link[ptr]) {
		semeailibs(G_ARMY(list[ptr]), &minlibs, &maxlibs, &typlibs, &hemin, &hemax, &memin, &memax);
		if (typlibs < bestval) {
			bestval = typlibs;
			bestgroup = (group_t)list[ptr];
		}
	}
	return bestgroup;
}

     
/* return result of reading for group g.  if live, trying to
 * live, else trying to kill.
 * try foughtalready first, then
 * look for subtrees in fight structure
 * return index of base of saved movetree
 * result indicates if group can live or can be killed
 */
     
int readliferesult(group_t g, int live, tree_t *movetree) {
	if (live && foughtalready(g, TRYTOLIVE, grcolor[g], movetree))
		return TR_RESULT(*movetree);
	if (!live && foughtalready(g, TRYTOKILL, 1-grcolor[g], movetree))
		return TR_RESULT(*movetree);
	return V_UNKNOWNRES;
}

/* read to see if group g can be killed (full board lookahead). 
 * returns the move tree, or NONE
 */
	
tree_t canbekilled(group_t g, int maxnodes, int maxdepth)
{
	tree_t movetree;
	list_t groups = EOL;
	
    g = biggestarmygroup(armygroups[grarmy[g]]);
	if (!foughtalready(g, TRYTOKILL, 1 - grcolor[g], &movetree))
		movetree = newtree();
	if (movetree == NONE)
		return NONE;	/* tree alocation failed */
	fightsize = 0;
	cpylist(armygroups[grarmy[g]], &groups);
	readlife(g, groups, FALSE, maxdepth, maxnodes, movetree);
	killist(&groups);
	 /* mark if can't be killed so won't read again */
	markfight(g, TRYTOKILL, 1 - grcolor[g], movetree);
	return movetree;
}


/* read to see if group g can make life (full board lookahead).
 * returns move tree.  pass it the number of nodes to read.
 * check for cached tree and expands it.  caches the result
 * return NONE if there is no space for a new tree
 */
	
tree_t canmakelife(group_t g, int maxnodes, int maxdepth)
{
	tree_t movetree;
	list_t groups = EOL;
	
    g = biggestarmygroup(armygroups[grarmy[g]]);
	if (!foughtalready(g, TRYTOLIVE, grcolor[g], &movetree))
		movetree = newtree();
		
	if (movetree == NONE)
		return NONE;
	fightsize = 0;
	cpylist(armygroups[grarmy[g]], &groups);
	readlife(g, groups, TRUE, maxdepth, maxnodes, movetree);
	killist(&groups);
	/* mark if can't make life so won't read again */
	markfight(g, TRYTOLIVE, grcolor[g], movetree);
	return movetree;
}
	
/* return the probability of group g living based just on
 * running away.  G's opponent moves first
 */	

extern int runval[20];

static int gliverunprob(group_t g)
{
	int runs, i;
	runs = armyrn_pot[G_ARMY(g)];
	for (i = 0; i < NUMRUN; ++i)  /* find and remove best running value */
		if (armyrun[G_ARMY(g)][i] != EOL) {
			runs -= runval[i];
			break;
		} 
	if (runs <= 0)
		return 0;
	if (runs > EASY_RUN)
		runs = EASY_RUN;
	return 95 * runs / EASY_RUN;
}


/* return probability that group can run away if it moves first */

static int gkillrunprob(group_t g)
{
	int runs;
	runs = armyrn_pot[G_ARMY(g)];
	if (runs > EASY_RUN)
		runs = EASY_RUN;
	return 95 * runs / EASY_RUN;
}
 
                               
/* return the probability that group g can make two eyes locally if
 * opponent moves first
 */
 
static int gliveprob(group_t g)
{
	int prob;
	army_t army;
	army = G_ARMY(g);
	if (armyeyespace[army] + armysecond[army] >= 16) {
		prob = 80 + armyrest[army] * 2 + armypthreat[army];
		if (prob > 95)
			prob = 95;
	}
	else {
		prob = armyeyespace[army] * 3 + armysecond[army] * 3 +
			armyrest[army] * 2 + armypthreat[army];
		if (prob > 80)
			prob = 80;
	}
	return prob;
}


/* return the probability that group g can make two eyes locally if
 * it moves first
 */
 
static int gkillprob(group_t g)
{
	int prob;
	army_t army;
	army = G_ARMY(g);
	if (armyeyespace[army] + armybestpot[army] >= 16) {
		prob = 80 + armysecond[army] * 2;
		if (prob > 95)
			prob = 95;
	}
	else {
		prob = armyeyespace[army] * 3 + armybestpot[army] * 3 +
			armysecond[army] * 2 + armyrest[army] * 2 + armypthreat[army];
		if (prob > 80)
			prob = 80;
	}
	return prob;
}


/* return the probability of g winning a semeai against its
 * neighbors.  neighbors move first
 */

static int gsemprob(group_t g)
{
	list_t moves,ptr;
	int bestprob = 0, hisbest, hisprob;
	if (armynbp[G_ARMY(g)] == EOL)
		getarmynbp(G_ARMY(g));
	for (ptr = armynbp[G_ARMY(g)]; ptr != EOL; ptr = link[ptr]) {
		if (livealive[A_ALIVE(list[ptr])])
			continue;
		moves = getsemeaimoves((group_t)list[armygroups[list[ptr]]], g);
		killist(&moves);
		hisbest = savesemval[0];
		hisprob = winsemprob(G_ARMY(g),(army_t)list[ptr], 0, hisbest);
		if (hisprob > bestprob)
			bestprob = hisprob;
	}
	return bestprob;
}
 
/* return the probability of g winning a semeai against its
 * neighbors.  g moves first
 */

static int gkillsemprob(group_t g)
{
	list_t moves,ptr;
	int bestprob = 0, hisprob;
	if (armynbp[G_ARMY(g)] == EOL)
		getarmynbp(G_ARMY(g));
	for (ptr = armynbp[G_ARMY(g)]; ptr != EOL; ptr = link[ptr]) {
		if (livealive[A_ALIVE(list[ptr])])
			continue;
		moves = getsemeaimoves((group_t)list[armygroups[list[ptr]]], g);
		killist(&moves);
		hisprob = winsemprob(G_ARMY(g), (army_t)list[ptr], 0, 0);
		if (hisprob > bestprob)
			bestprob = hisprob;
	}
	return bestprob;
}

                              
/* return the probability of group g living.  result is the result
 * from liveresult.  it is g's opponent's turn to move
 * look at probability of making eyes, running, or killing neighbors
 */

int liveprob(group_t g)
{
	return 50 + gralval[g][1];
}                                                               
	
/* return the probability of group g being killed.  result is the result
 * from killresult.  it is g's turn to move.
 */
 
int killprob(group_t g)
{
	return 50 - gralval[g][0];  /* 50 means certain life, so return 0 */
}



int history[NUMSQUARES];	/* history heuristic values */

/* TODO: use history heuristic, and initialize it from incoming tree */
static void rlinit(tree_t result)
{
	int i;
	for (i = 0; i < NUMSQUARES; ++i)
		history[i] = 0;
}

/* get the adjusted bf value for a node. */

static int getbfval(tree_t node)
{
	int tbf, delta;
	tbf = tr[node].bf;
	if (tr[node].ob && !tr[node].evaluated) {  /* bonus for taking opponent's winning move */
		delta = (100 - tr[node].bf) / 2; 
		if (delta > 10 + 5 * tr[node].ob)
			delta = 10 + 5 * tr[node].ob;
		tbf += delta;
		if (tbf > 100)
			tbf = 100;
	}
	return tbf;
}

/* select the next leaf node to scout.  start at root.
 * if child has success, move to that child.
 * if no successful children, take the highest probability
 * failure or unevaluated child.
 * return TRUE if find node, FALSE if no more nodes to expand
 * return the path from the root to the leaf in path, with 
 * leaf node first and root last.
 */

static int rlselect(tree_t root, list_t *path)
{
	tree_t current = root, tmp;
	int bf, tbf;
	int successbf = 0;  /* best bf value for a successful move */
	int successprob = 0;	/* best confidence for a successful move */
	int havesuccess;
	int found;
	int depth = 0;	 /* actual depth in tree */
	killist(path); 
	for (;;) {  
		adflist(current, path);
		depth++;
		bf = -1;
		if (tr[current].child == NONE && !tr[current].evaluated)
			return TRUE;	/* at leaf, go explore */

		havesuccess = FALSE;
		/* if (depth != 1) {   try all moves at ply 1  - bad plan - prove it good first */
		for (tmp = tr[current].child; tmp != NONE; tmp = tr[tmp].sib) {
			if (tr[tmp].evaluated && TR_RESULT(tmp) >= V_WINLIKELY) {
				if (tr[tmp].bf != 0)
					havesuccess = TRUE; /* have more exploration to do on a successful branch */
				if (tr[tmp].bf > successbf)
					successbf = tr[tmp].bf;
				if (TR_PROB(tmp) > successprob)
					successprob = TR_PROB(tmp);
			}
		}
				
#ifdef NEVER
				1/31/99 allow it to take unevaluated if successful links less than 1/2
				&&
				(depth != 1 || TR_PROB(tmp) < 90))
				/* try more moves at depth 1 if have some confidence in first one 
				 * want to prove at least one move to 90% confidence before look at the rest.
				 */
				break;	  /* take success branch if have one */
		if (tmp != NONE) {
			current = tmp;
			continue;	/* found a move */
		}
#endif
		found = FALSE;
		for (tmp = tr[current].child; tmp != NONE; tmp = tr[tmp].sib) {
			if (tr[tmp].bf == 0)
				continue;	/* 5/02 this tree completely evaluated.  If take it, will exit search early */
			if (havesuccess && successprob < 80 && /* 5/02 once one branch to 80%, give more tries on others */
				tr[tmp].evaluated && TR_RESULT(tmp) < V_WINLIKELY)
				continue;	/* don't take failure if have a sucess */
			if (havesuccess && !tr[tmp].evaluated && depth != 1)
				continue;	/* don't take unevaluated if have a success, except at root */
			tbf = getbfval(tmp);
			if (depth == 1 && !tr[tmp].evaluated)
				tbf += 20;	/* extra value to try moves at ply 1 */
			/* 3/04 added new history heruistic */
			if (!tr[tmp].evaluated)	/* only new moves - otherwise high history values prevent trying new moves */
				tbf += history[tr[tmp].s]>>3; 
			if (havesuccess) {
				if (!tr[tmp].evaluated)
					tbf /= 2;  /* prefer to improve the sucess unless unlikely to win */
				else if (TR_RESULT(tmp) == V_WINKO)
					tbf /= 2;	/* 3/04 prefer to concentrate on success rather than kos */
			}
			if (tbf > bf) {
				bf = tbf;
				current = tmp;	/* take child with best bf value, modified by opponent's best */
				found = TRUE;
			}
#ifdef NEVER
			if (depth < MAXKILLPLY && tr[tmp].s == killer[depth] && !tr[tmp].evaluated) {
				current = tmp;
				found = TRUE;
				break;	/* take killer move if have it */
			}
#endif
		}
		if (!found)
			return FALSE;
	}
	return FALSE;
}

/* path and current are lists of tree indexes,
 * with deeper nodes first.  Current input is the path to the current location
 * path is the path to the desired node.  Move from current to path, and change current to match
 * current is output, path to location in tree after goto operation
 * return depth the depth from root to current position (root is 1), ignoring forced moves
 */

static tree_t rlgoto(tree_t result, list_t *path, list_t *current, int color, int *depth)
{
	tree_t t;
	int res;
	list_t ptr;
	*depth = 1;
	if (list[*path] == list[*current])
		return list[*path];					    /* already at the right place */
	while (link[*current] != EOL) {	/* back up to root */
		dndate();
		dlflist(list[*current], current);
	}
	killist(current);
	revlist(path);	/* make it start at the root */
	adflist(list[*path], current);
	ptr = *path;
	while  (link[ptr] != EOL) {
		ptr = link[ptr];
		for (t = tr[result].child; t != NONE; t = tr[t].sib) {
			if (t == list[ptr]) {
				if (tr[t].s != PASS && board[tr[t].s] != NOGROUP) {	/* expanding reading has found a stone on a generated move */
					deletechildren(result);	/* stop here, delete all children, and generate moves at this node again */
					tr[result].evaluated = FALSE;  /* TODO: do I have to back up move values to root now, or does the coming rlscout/rlvalues do it correctly? */
					tr[result].ob = FALSE;
					tr[result].kocolor = NOCOLOR;
#ifdef G2DEBUGOUTPUT
					outerror("Bad move in rlgoto");
#endif
					return result;
				}
				if (tr[t].s == kosquare) {  /* illegal ko capture */
					if (tr[result].kocolor != NOCOLOR &&
						tr[result].kocolor != color) {  /* can't make this move */
						deletetree(result, t);
						return result;
					}
					setkocolor(t, color);  /* only I can capture kos now */
				}
				res = update(tr[t].s, color, TRUE);
				if (res != TRUE) {
					if (res != -1) {
						dndate();
					}
					deletetree(result, t);	/* delete the illegal move from the tree */
					return result;		/* need to handle this case - illegal move generated! */
				}
				adflist(t, current);
				if (tr[tr[result].child].sib != NONE)
					(*depth)++;	 /* don't count forcing moves in depth */
				color = 1 - color;
				result = t;
				break;
			}
		}
	}
	return list[ptr];
}

/* generate moves to try to live or kill group g, add to move tree */

static void rlgenerate(tree_t node, group_t g, list_t groups, int live, int color, int depth) {
	list_t movelist = EOL, ptr;
	int prob;
	int genned = 0;

	if (live)
		movelist = lifesetmoves(groups); /* combo prob,move for all groups*/
	else { 	
		movelist = killmoves(g);  /* combo prob,move */
	}
	/* dlflist(kosquare,&movelist);  should generate ko threat here? */
	if (grlibs[g] > 2)
		dellistm(PASS, &movelist, MV_MASK);
	dellistm(NOSQUARE, &movelist, MV_MASK);
	for (ptr = movelist; ptr != EOL; ptr = link[ptr]) {
		if (MV_MV(list[ptr]) >= boardsquare && MV_MV(list[ptr]) != PASS ||
			board[MV_MV(list[ptr])] != NOGROUP) {
#ifdef CHECK
			outerr("illegal move in rlgenerate");
#endif
			continue;	/* illegal move */
		}
		if (MV_MV(list[ptr]) == PASS && tr[node].s == PASS)
			continue;	/* don't allow two passes in a row */
		prob = (50-MV_PROB(list[ptr]))*2;  /* movelist is 0-50, prob of failure.  make it 0-100, prob of success */
#ifdef G2DEBUGOUTPUT
		if (prob > 100) {
			prob = 100;
			outerror("Bad prob in rlgenerate");
		}
		if (prob < 0) {
			prob = 0;
			outerror("Bad low prob in rlgenerate");
		}
#endif
		if (depth > 2 && (prob < 10 && genned > 4 || prob < 50 && genned > 6))
			continue;	/* save space in the tree */
		if (prob <= 0)
			prob = 1;  /* since 0 is special bf value
		/* if no nodes left, this doesn't add the child */
		addlastchild(node, MV_MV(list[ptr]), prob, V_UNKNOWNRES); 
		genned++;
	}
	killist(&movelist);
}


/* current position has not been evaluated yet - it is a leaf 
 * expand starting at node, and descend to a leaf
 * live is goal to live or not, at root of tree
 * depth is initial depth from root (root = 1), ignoring forced moves
 * return number of new life calls
 */
static int rlscout(tree_t node, list_t *path, group_t g, list_t groups, int live, int maxdepth, int tomove, int depth, int trial)
{
	int result, prob;
	group_t newg;
	int wins, res;
	int size = 0;
	int color = tomove;
	tree_t tmp;
	int realdepth = depth;

	if ((cntlist(path)&1) == 0) {
		color = 1-color;
	}
	else
		live = !live;

	for (;;) {  /* descend first generated path to a leaf node  */
			  /* TODO: add check for each move that group is not tactically captured */
		life(FALSE);
		newg = board[mvs[grpieces[g]]];
		if (grlv[newg])
			newg = biggestarmygroup(groups);
		size++ ;
		if (live) {
			result = liveresult(newg, newg);
			prob = liveprob(newg);
		}
		else {
			result = killresult(newg, newg);
			prob = killprob(newg);
		}
		wins = resvalue[result];
		if (realdepth == 1) {	 /* try one ply at least */
			if (wins == V_WIN)
				wins = V_WINLIKELY;
			if (wins == V_LOSE)
				wins = V_LOSELIKELY;
		}

		setvalue(node, prob, wins);
		settrial(node, trial);
		live = !live;

		if (wins == V_WIN || wins == V_LOSE)
			return size;				/* found leaf */
		if (depth > maxdepth / 2 && (wins == V_WINLIKELY || wins == V_LOSELIKELY)) {
			rlgenerate(node, newg, groups, live, color, depth);
			return size;				/* probable leaf over maxdepth - allow early stop and can return here later */
		}
		if (depth > maxdepth)
			return size;		/* absolute maximum depth also */

		rlgenerate(node, newg, groups, live, color, depth);
		for (;;) {  /* take first legal child */
			if (tr[node].child == NONE) { /* no child moves generated - no moves work to win fight */
				if (wins == V_UNKNOWNRES)
					wins = V_WINLIKELY;

				setvalue(node, prob, wins);
				settrial(node, trial);
				return size;
			}
			tmp = tr[node].child;
			if (tr[tmp].s == kosquare) {
				if (tr[node].kocolor != NOCOLOR &&
					tr[node].kocolor != color) {	/* can't allow to retake the ko, so change move to a pass */
					tr[tmp].s = PASS;
					/*deletetree(node, tmp); 5/02 make it a pass rather than delete it
					  continue; */
				}
				else 
					setkocolor(tmp, color);
			}
			else if (tr[tmp].s != PASS && board[tr[tmp].s] != NOGROUP) {
				deletetree(node, tmp);
				continue;	/* illegal move ignored and deleted */
			}
			res = update(tr[tmp].s, color, TRUE);
			if (res == TRUE) {
				adflist(tmp, path);
				if (tr[tmp].sib != NONE || tr[tmp].s == PASS)
					depth++;  /* don't add depth for forcing move */
				realdepth++;
				color = 1-color;
				node = tmp;
				break;			/* found a good child */
			}
			else{
				if (res != -1) {
					dndate();	/* delete illegal move */
				}
				deletetree(node, tmp);
			}
		}
	}
	return size;
}


/* are we done with this lookahead? */

int rldone(int result, int size, int maxsize, int rescount) {
	if (size >= maxsize/2 && rescount > 2 || size >= maxsize)	/* looked at enough nodes */
		return TRUE;
	if (thinking())		/* user asks to stop */
		return TRUE;
	return FALSE;
}

void rlgotoroot(list_t loc) {
	int num = cntlist(&loc)-1;
	int i;

	for (i = 0; i < num; ++i) {
		dndate();
	}
}

/* adjust bf of failing node when refutation found - play at opponent's move */
void adjustbf(tree_t parent, sqr_t s) {
	tree_t ptr;
	for (ptr = tr[parent].child; ptr != NONE; ptr = tr[ptr].sib)
		if (tr[ptr].s == s && tr[ptr].bf != 0)
			tr[ptr].ob++;	/* this move same as opponent's refutation move */
}

/* recalculate all values along path 
 * use bf (best failure) values to find next failing node to expand.
 * exactly one leaf has a new value when this is called.
 * path is a list of all nodes on path from new leaf to root, deepest first.
 * NEEDS work - change values based on search results - killer, opponent best move, etc.
 */
void rlvalues(list_t path)
{
	tree_t node, ptr;
	int win = V_LOSE;
	int prob;
	int prob1 = 0;
	int prob2 = 0;
	int winprob = 0;	/* best probability of successful child */
	int bf;				/* best failing child's success prob (when all children fail) */
	int wbf;			/* best winning child's bf */
	int tbf;
	int nebf; /* best not evaluated bf */
	int depth = cntlist(&path);	   /* actual depth in tree - for killer */
	int haveko;

	if (tr[list[path]].child == NONE) {
		win = TR_RESULT(list[path]);
		tr[list[path]].bf = 0;  /* never good to expand a leaf */
		path = link[path];	/* back up one level first */
	}
	while (path != EOL) {
		node = list[path];
		depth--;
		prob1 = 2;	/* best two losing children probabilities */
		prob2 = 2;	/* start nonzero, since there might be moves not generated that win the fight */
		bf = wbf = nebf = 0;
		win = V_LOSE;
		haveko = FALSE;
		winprob = 0;
		for (ptr = tr[node].child; ptr != NONE; ptr = tr[ptr].sib) {
			prob = TR_PROB(ptr);
			if (tr[node].kocolor == NOCOLOR &&
				tr[ptr].kocolor != NOCOLOR) {
				prob = prob*1/3;	/* 1/1/99 ko captures only get 2/3 of value. 5/01 only 1/3 of value since capture illegal ko, so need two moves */
				haveko = TRUE;
			}
			if (prob > prob1) {
				prob2 = prob1;
				prob1 = prob;
			}
			else if (prob > prob2)
				prob2 = prob;
			if (tr[ptr].evaluated && TR_RESULT(ptr) >= V_WINLIKELY && prob > winprob)
				winprob = prob;
			if (tr[ptr].evaluated && TR_RESULT(ptr) > win) {
#ifdef NEVER
				if (win >= V_WINLIKELY)
					history[tr[ptr].s] += 5;
				killer[depth] = tr[ptr].s;
#endif
				win = TR_RESULT(ptr);
				if (win >= V_WINLIKELY && link[path] != EOL)
					adjustbf(list[link[path]], tr[ptr].s);  /* raise values on this move at my level */
				tbf = tr[ptr].bf;
				if (tr[node].kocolor == NOCOLOR &&
					tr[ptr].kocolor != NOCOLOR)
					tbf /= 3;	/* options after ko only count for 1/3 */
				if (win >= V_WINLIKELY && tbf > wbf)
					wbf = tbf;
			}
			if (!tr[ptr].evaluated && tr[ptr].bf > nebf)
				nebf = tr[ptr].bf;
			tbf = getbfval(ptr);
//			if (tr[node].kocolor == NOCOLOR &&
//				tr[ptr].kocolor != NOCOLOR) {
//				tbf /= 3;
//			}
			if (tbf > bf)
				bf = tbf;   /* set importance of trying this move next */
		}

		if (win >= V_WINLIKELY) {  /* unevaluated moved can't be better than evaluated winning moves */
			if (prob1 > winprob)
				prob1 = winprob;
			if (prob2 > winprob)
				prob2 = winprob;
		}
		prob = (100-prob1)*(100-prob2)/100;  /* use prob of two losing children since all must lose */
		if (win >= V_WINLIKELY) {
			/* 12/02 - prob is prob of success, and success always requires all to fail.prob = 100-winprob;  /* use prob of best winning child, since only one winner is needed */
			tr[node].bf = (wbf * (100 - nebf) + 99)/100;  /* have winning child, use its bf value, adjusted for nebf. rounded up */
								/* I am a failing node.  To make me success, wbf must fail, */
								/* and nebf must also fail. */
		}
		else {
			tr[node].bf = bf;	/* no winning child, use best bf value found */
								/* I am a sucess node.  only takes one of my children to make me fail */
		}
//		tr[node].bf = tr[node].bf * 9/10;	/* 3/04 bias toward the root - no - misses many problems */
		if (win > V_WINKO && haveko)
			win = V_WINKO;
		if (prob > 100) {
			prob = 100;
#ifdef G2DEBUGOUTPUT
			outerror("prob out of range in rlvalues\n");
#endif
		}

		win = oppvalue[win];
#ifdef NEVER
//		if (win >= V_WINLIKELY && TR_RESULT(node) == V_WINKO)
//			win = V_WINKO;
#endif
		if (win >= V_WINLIKELY &&
			(!tr[node].evaluated || TR_RESULT(node) < win)) {
#ifdef NEVER
			history[tr[node].s] += 1024 >> depth;	// exponential history only hurts performance
#endif
			if (depth < 10)
				history[tr[node].s] += (10-depth);
		}
		setvalue(node, prob, win);
		path = link[path];
	}
}

/********************************************************************
 life and death reading code is here
 ********************************************************************/
#define MAXREAD 256	/* enough to hold all possible groups */

group_t toread[MAXREAD];	/* groups to read, one per army */
int nodes[MAXREAD][2];		/* nodes to use for reading by 0=trytolive, 1=trytokill */
int atkdefval[MAXREAD];		/* value of atack or defense of this group */
int lastprob[MAXREAD][2];	/* last reading result - stop when stable */

/* size of fight, in points */
int getfightsize(army_t army) {
	list_t ptr, ptr2, liblist = EOL;
	int size = armysize[army];
	for (ptr = armylbp[army]; ptr != EOL; ptr = link[ptr]) {
		if (ltr1[list[ptr]] && ltrgd[list[ptr]] != 2)size += ltr1[list[ptr]] - 1;
		else if (!S_NEUTRAL(list[ptr]) &&
		   lnbn[list[ptr]] > 1)
		   	for (ptr2 = nblbp[list[ptr]]; ptr2 != EOL; ptr2 = link[ptr2])
		   		if (ld[list[ptr2]] == NOLD && 
		   		   ltr1[list[ptr2]] == 0 &&
		   		   addlist(list[ptr2],&liblist))size ++;
		}
	killist(&liblist);
	size += armylibs[army]-1;  /* since enemy will fill one to catch me */
	/* size++;  /* a little extra to encourage saving groups */
	return size;
}

int fightatkdefval(army_t army, group_t g, int tm) {
	int val;	/* biggest possible value of this fight.  if it is big enough, should read it */
	int aval;	/* best estimate of actual value, to determine how many nodes to allocate */
	int livenbr, bignbr;
	list_t ptr;
	val = getfightsize(army) * 50;
	val += cut_stones_val(army);
	if (A_COLOR(army) != tm && A_THREATENED(army)) {
		if (armynbp[army] == EOL)
			getarmynbp(army);
		livenbr = FALSE;
		bignbr = FALSE;
		for (ptr = armynbp[army]; ptr != EOL; ptr = link[ptr]) {
			if (A_SIZE(list[ptr]) >= A_SIZE(army) && 
				A_ALIVE(list[ptr]) >= WEAK_POTENTIAL && A_ALIVE(list[ptr]) > ALIVE) {
				bignbr = TRUE;	/* prefer to save own group to capture enemy (since he might be just an eye) */
			}
			if (A_ALIVE(list[ptr]) <= ALIVE)
				livenbr = TRUE;
		}
		if (!livenbr) {
			val /= 2;
			if (bignbr)
				val /= 2;
		}

	}
	if (val < obaval * 3/4)
		return 0;

	aval = val * (50 + gralval[g][0] - gralval[g][1]) / 100;

	if (val < obaval*3/2)  /* 7/01 do some reading for safety */
		aval = aval * (val-obaval*3/4)/(obaval*3/4);  /* linearize from obaval*3/2 to 3/4 */

	return aval;
}

/* find groups that need some reading, and set the size of the fight 
 * color is the side to move
 */
static int findgroups(int color) {
	group_t g;
	list_t tmplist = EOL;
	army_t army;

	int nextread = 0;
	for (g = 0; g < maxgr; ++g) {
		if (!grlv[g])continue;
		army = grarmy[g];
		if (inlist(army, &tmplist))continue;
		addlist(army, &tmplist);	/* only look at each army once */
		if (G_ALIVE(g) == HAS_TWO_EYES || G_ALIVE(g) >= WEAK)
			continue;	/* certain of result */
		if (armyrn_pot[army] > 5)continue;	/* don't read if can run away */
#ifdef NEVER
		if (grsize[g] <= 2 && grlibs[g] == 1 && 
			eyepot[eyerec[mvs[grpieces[g]]]] == 0)continue;
#endif
		toread[nextread] = g;
		lastprob[nextread][0] = lastprob[nextread][1] = 0;	/* middle value */
		atkdefval[nextread++] = fightatkdefval(army, g, color);
	}
	killist(&tmplist);
	return nextread;
}

/* what is the ideal node count to this group 
 * depends on the size of the fight and the confidence of the result
 * but make it at least 5 nodes for efficiency
 */
static int idealnodes(int rn, int trytokill) {
	int nb, nodes, res, prob;
	int color;  /* color to move */
	group_t g;
	tree_t tr;
    g = toread[rn];
	color = trytokill?1-G_COLOR(g):G_COLOR(g);
	if (!trytokill) {
		nb = TRYTOLIVE;
		if (G_ALIVE(g) <= ALIVE)
			return 0;	/* don't try to make living group live */
	}
	else {
		nb = TRYTOKILL;
		if (armyrn_pot[G_ARMY(g)] > 3)
			return 0;	/* don't try to kill group that can run away */
	}
	nodes = atkdefval[rn]*4/50;	/* for now, 4 nodes per point in group if it is unsettled */
	res = readliferesult(g, color == grcolor[g], &tr);
	if (res != V_UNKNOWNRES) {	/* if already have a reasonable result, reduce the number of nodes */
		prob = treealprob(tr, gralprob[g], color == grcolor[g]);	/* -50 to 50 */
		if (color != grcolor[g])
			prob = -prob;	/* trying to kill, so need to invert to get low alprobs to high success probs */
		if (res == V_WIN)
			nodes = nodes*(60-prob)/100;	/* don't do much if confident */
		else if (res == V_WINLIKELY)
			nodes = nodes*(70-prob)/100;	/* get more certain */
		else if (res == V_LOSE)
			nodes = nodes*(prob+55)/100; 
		else if (res == V_LOSELIKELY)
			nodes = nodes*(prob+70)/100;
		if (lastprob[rn][trytokill] == prob &&
			(prob <= -40 || prob >= 40))
			nodes = 0;		/* stable, so no more reading */
		lastprob[rn][trytokill] = prob;
	}
	else {	/* no reading yet */
		prob = (gralprob[g] < 0? -gralprob[g] : gralprob[g]);
		nodes = nodes * (100-prob)/100;		/* fewer nodes if less unsettled */
	}
	if (nodes < 5 && nodes > 0)	/* need to do at least 5 nodes :) */
		nodes = 5;
	return nodes;
}

#ifdef G2DEBUGOUTPUT
extern int logsearch;
extern FILE *logfile;
#endif


/* allocate nodes to reading by type of reading 
 * based on:
 *   size of potential disaster, confidence of curent reading result
 * get all the ideal node counts and then scale then
 */

static int allocnodes(int maxnodes, int nextread) {
	int i, sum = 0, target;
	if (maxnodes < 5)
		return FALSE;
	for (i = 0; i < nextread; ++i) {
		nodes[i][0] = idealnodes(i, 0);
		nodes[i][1] = idealnodes(i, 1);
		sum += nodes[i][0] + nodes[i][1];
	}
	
	if (sum > maxnodes)
		target = maxnodes;	/* reduce to maxnodes */
	else if (sum < maxnodes/4)
		target = maxnodes/4;	/* increase to maxnodes/4 */
	else target = sum;
	if (target != sum) {	/* adjust nodes to total to about target */
		for (i = 0; i < nextread; ++i) {
			if (nodes[i][0] != 0) {
				nodes[i][0] = nodes[i][0] * target / sum;
				if (nodes[i][0] < 4)
					nodes[i][0] = 4;
			}
			if (nodes[i][1] != 0) {
				nodes[i][1] = nodes[i][1] * target / sum;
				if (nodes[i][1] < 4)
					nodes[i][1] = 4;
			}
		}
	}
#ifdef G2DEBUGOUTPUT
	if (logsearch && logfile != NULL)fprintf(logfile, "Allocating %d nodes, %d ideal, %d target\n", maxnodes, sum, target);
#endif
	return sum > 0;
}

static int fightresult(group_t g, int live) {
	tree_t movetree;
	int res;
    g = biggestarmygroup(armygroups[grarmy[g]]);
	res = foughtalready(g, (group_t)(live?TRYTOLIVE:TRYTOKILL), live?G_COLOR(g):1-G_COLOR(g), &movetree);
	if (!res)
		return V_UNKNOWNRES;
	else
		return TR_RESULT(movetree);
}


/* do life and death reading for each group that has been identified.
 * if group is strong or weak, read one side first, and only read the other side if the
 * status can change
 */

static void doreading(int nextread) {
	int i;
#ifdef G2DEBUGOUTPUT
	char buf[20], *p;
	int oldlifecalls = numlifecalls, prob;
	tree_t t;
	group_t g;
#endif
	for (i = 0; i < nextread; ++i) {
		if (nodes[i][0] == 0 && nodes[i][1] == 0)
			continue;
		if (G_ALIVE(toread[i]) <= ALIVE) {  /* strong group.  see if can be killed, and if so, read how to save it */
			if (nodes[i][1] > 0) {
				canbekilled(toread[i], nodes[i][1], maxfightdepth[playlevel]); 
				if (nodes[i][0] > 0 && fightresult(toread[i], FALSE) >= V_UNKNOWNRES) {
					canmakelife(toread[i], nodes[i][0], maxfightdepth[playlevel]); 
					}
				}
			}
		else if (G_ALIVE(toread[i]) >= WEAK_SEMEAI) {  /* weak group.  see if can be saved, and if so, read how to kill it */
			if (nodes[i][0] > 0) {
				canmakelife(toread[i], nodes[i][0], maxfightdepth[playlevel]); 
				if (nodes[i][1] > 0 && fightresult(toread[i], TRUE) >= V_UNKNOWNRES) {
					canbekilled(toread[i], nodes[i][1], maxfightdepth[playlevel]); 
					}
				}
			}
		else {
			if (nodes[i][0] > 0)
				canmakelife(toread[i], nodes[i][0], maxfightdepth[playlevel]); 
			if (nodes[i][1] > 0)
				canbekilled(toread[i], nodes[i][1], maxfightdepth[playlevel]); 
			}
#ifdef G2DEBUGOUTPUT
		if (logsearch) {

			fprintf(logfile, "Fight read %s allocs (%d, %d) nodes. Evals used %d\n", 
				ssqr(mvs[grpieces[toread[i]]], buf), nodes[i][0], nodes[i][1], numlifecalls-oldlifecalls);
		    g = biggestarmygroup(armygroups[grarmy[toread[i]]]);
			if (nodes[i][0] > 0 && foughtalready(g, TRYTOLIVE, grcolor[toread[i]], &t)) {
				p = treeres(t, &prob);
				fprintf(logfile, "    Try to live: %s %d%% prob.  %d total, %d evaluated\n", p, prob, counttree(t), countevaltree(t));
			}
			if (nodes[i][1] > 0 && foughtalready(g, TRYTOKILL, 1-grcolor[toread[i]], &t)) {
				p = treeres(t, &prob);
				fprintf(logfile, "    Try to kill: %s %d%% prob.  %d total, %d evaluated\n", p, prob, counttree(t), countevaltree(t));
			}
			oldlifecalls = numlifecalls;
		}
#endif
	}
}

/* do all of the life and death reading before move 
 * find all groups that need reading, and do some reading, either to
 * extend existing reading or do new reading.
 * color is the side to move
 *
 * groups to read include:
 *  if big enough,
 *  any groups with strength between BARELY_ALIVE and WEAK_POTENTIAL
 *
 *  WEAK_POTENTIAL and WEAK_SEMEAI to see if they can live (from urgatk/defgroups)
 *  BARELY_ALIVE through WINS_SEMEAI to see if they can be killed (from urgatk/defgroups)
 *  Any other groups b
 *  
 */
void lifereading(int color, unsigned int stoptime, int maxnodes) {
	int oldlifecalls;
	int nextread;
	int alloc = maxnodes/10;
	if (alloc > 100)
		alloc = 100;
	life(FALSE);
	nextread = findgroups(color);	/* find the groups to read */
	while(allocnodes(alloc, nextread)) {	/* allocate nodes to groups */
		oldlifecalls = numlifecalls;
		doreading(nextread);	/* do a pass of reading */
		if (numlifecalls == oldlifecalls)
			break;	/* not making any forward progress. */
		if (GetTickCount() > stoptime || thinking() || numlifecalls > maxnodes)
			break;
	}
	life(TRUE);	/* update all life values since probs changed */
}

int solvingproblem = FALSE;
static int trial;
#ifdef G2DEBUGOUTPUT
extern char logfilename[];
#endif
int stabletrials, stablesize;	/* for debug, number of trials and nodes to get a stable result */
extern int totstablenodes;

/* solve a life and death problem with color to move and return result in s */
void solveld(int color, sqr_t *s)
{
	group_t g;
	int i, prob, which, besti;
	int best, nextread, good = FALSE;
	list_t groups = EOL;
	tree_t movetree, bestnode;
	char *res;
#ifdef G2DEBUGOUTPUT
	int starttime = GetTickCount();
	int lifenodes = numlifecalls;
	char buf[1000], sbuf[20];
	FILE *f;
	if (logsearch) {
		logfile = fopen("\\go\\wingovs\\searchlog.txt", "w");
		if (logfile == NULL) {
			logsearch = FALSE;
		}
		else
			fprintf(logfile, "Start a new life/death search.\n");
	}
#endif
	fixplaylevel(MAXLEVEL);
	getobaval();
	life(2);
	nextread = findgroups(color);
	*s = PASS;
	if (nextread == 0)
	{
		return;
	}
	do {
		best = -1000;
		besti = 0;
		for (i = 0; i < nextread; ++i)
		{
			if (atkdefval[i] > best) {
				best = atkdefval[i];
				g = toread[i];
				besti = i;
			}
		}
		if (best <= 0)
			break;
		atkdefval[besti] = -1000;
		movetree = newtree();
		if (movetree == NONE) {
			*s = PASS;
			return;
		}

	    g = biggestarmygroup(armygroups[grarmy[g]]);
		cpylist(armygroups[grarmy[g]],&groups);
		numlifecalls = 0;
		readlife(g, groups, G_COLOR(g) == color, maxfightdepth[playlevel], 500, movetree);
		markfight(g, (group_t)(G_COLOR(g) == color?TRYTOLIVE:TRYTOKILL), color, movetree);
		life(FALSE);
		totstablenodes += stablesize;
		bestnode = bestchild(movetree, &which);
		if (bestnode == NONE)
			*s = PASS;
		else
			*s = tr[bestnode].s;
		res = treeres(movetree, &prob);
		good = TR_RESULT(movetree) >= V_WINKO;
#ifdef G2DEBUGOUTPUT
		sprintf(buf, "group at %s.  %s:%3d%%, gen #%2d, trials %3d (stable trials %3d, evals %3d)\n", 
			ssqr(mvs[grpieces[g]], sbuf), res, prob, which, trial, stabletrials, stablesize);
		f = fopen(logfilename, "a");
		if (f != NULL) {
			fputs(buf, f);
			fclose(f);
		}
#endif
		killist(&groups);
	} while (!good);
#ifdef G2DEBUGOUTPUT
	if (logsearch) {
		fprintf(logfile, "Complete in %5.2f secs.  Total evals %d, search evals %d\n", 
			(GetTickCount() - starttime)/1000., numlifecalls, numlifecalls-lifenodes);
		fclose(logfile);
		logfile = NULL;
	}
#endif
}

/* this one is not recursive 
 * read life and death using probability scout algorithm
 *
 * g is the group to read.
 * groups is the list of groups in g's army at the start of the fight
 * live is TRUE if g is trying to live, and FALSE if opponent is trying to kill g
 * maxdepth is the longest path to scout, in ply, from the root, not counting forced moves
 * maxsize is the maximum number of new nodes evaluated during this readlife call. lookahead will stop at
 *   the first reasonable spot after maxsize nodes have been evaluated, and won't evaluate more than twice that many nodes
 * movetree
 * result is the returned tree (index of the root node of the tree).  This node has already been initialized 
 * before readlife is called, and may be just a single root node, or an entire previous search tree
 *
 * need to read all moves at ply 1 (or send in flag to ask for all to be read,
 * or read all that have high enough initial probability)
 *
 * Algorithm:
 * 
 * This is a best first search, with the entire search tree remembered.
 * rlinit() intializes the search
 * rlselect() finds the best leaf node to expand.
 * rlgoto() moves the engine state to that node
 * rlscout() expands a line of moves from that leaf until a good evaluation is reached
 * rldone() checks to see if the search is finished
 *
 */

/* number of consecutive returns of same value for stability */
#define NUMSTABLE 3

#ifdef G2DEBUGOUTPUT
static char * fightres[] = {
	"FL",
	"F?",
	"??",
	"KO",
	"W?",
	"WN"
};
#endif

static void readlife(group_t g, list_t groups, int live, int maxdepth, int maxsize, tree_t result)
{
	int done = FALSE;
	int prob, tmp;
	int win;
	list_t path = EOL;			/* path from root to selected node */
	list_t location = EOL;		/* path from root to current location in tree */
#ifdef G2DEBUGOUTPUT
	list_t tmplist = EOL, ptr;
	char buf[20];
#endif
	int tomove;					/* color to move */
	tree_t node;				/* node in tree to expand */
	int size = 0;					/* number of nodes evaluated */
	int depth;
	int nextdump = 1;
	int lastwin = V_UNKNOWNRES;	/* last result of fight */
	int rescount = 0;				/* number of cycles with the same result - want to return consistent result */
	tree_t stablechild = NONE;	/* stable child node */
	tree_t best = NONE;		/* best child node */

	trial = 0;		/* current trial/probe number */
	stabletrials = stablesize = 0;

	if (live)
		tomove = G_COLOR(g);
	else
		tomove = 1-G_COLOR(g);

	if (result == NONE)	/* passed in an unallocated tree */
		return;
	/* outside result is reversed from internal, so fix it in case there is no reading done */
	if (tr[result].evaluated) {
		prob = 100-TR_PROB(result);
		win = oppvalue[TR_RESULT(result)];
		setvalue(result, prob, win);
	}
	
	if (g == NOGROUP) {
#ifdef CHECK
		outerror("readlife called with empty square\n");
#endif	
		prob = 100-TR_PROB(result);
		win = oppvalue[TR_RESULT(result)];
		setvalue(result, prob, win);
		return;
	}
	adflist(result, &location);			/* current location is at root of tree */
	rlinit(result);							/* initialize search */
	/* each time around loop, scout one path to a good leaf node */
	while (!done) {
		if (!rlselect(result, &path))	/* select unevaluated leaf node to expand, set path from selected node back to root */
			break;						/* no moves left to try */
		node = rlgoto(result, &path, &location, tomove, &depth);	/* go to the node to expand, use location to reach root, update location */
		if (!tr[node].evaluated) {   /* rlgoto reached the leaf node */
			size += rlscout(node, &location, g, groups, live, maxdepth, tomove, depth, trial);  /* scout down to leaf, set location */					
			trial++;
								/* expand single line till result */
		}
		rlvalues(location);					/* update the values in the tree. location is path from leaf back to root */
		win = oppvalue[TR_RESULT(result)];
		if (win == lastwin)
			rescount++;
		else {
			lastwin = win;
			rescount = 0;
		}
		done = rldone(result, size, maxsize, rescount);			/* done enough reading */
#ifdef G2DEBUGOUTPUT
		if (logsearch && logfile != NULL) {
			fprintf(logfile, "%2d %s %s %s %3d:", 
				trial, live? "save" : "kill", ssqr(mvs[grpieces[g]], buf),
				fightres[win], 100 - TR_PROB(result));
			if (location == EOL || link[location] == EOL) {
				fprintf(logfile, "Empty location!");
			}
			cpylist(location, &tmplist);
			tmplist = revlist(&tmplist);
			for (ptr = link[tmplist]; ptr != EOL; ptr = link[ptr]) {
				fprintf(logfile, " (%s %s%3d:%3d)", 
					ssqr(tr[list[ptr]].s, buf), 
					fightres[TR_RESULT(list[ptr])], 
					TR_PROB(list[ptr]),
					tr[list[ptr]].bf);
			}
			killist(&tmplist);
			fprintf(logfile, "\n");
		}
#endif
		best = bestchild(result, &tmp);
		if (best != stablechild) {
			stablechild = best;
			stabletrials = trial;
			stablesize = size;
		}
		if (solvingproblem) {
			if (size > nextdump && rescount > 2) {  /* want to show steady results */
				nextdump = size + 20;
				problemprogress(
					size-1,
					oppvalue[TR_RESULT(result)],
					100-TR_PROB(result));
			}
		}
	}
	if (solvingproblem) {
		problemprogress(
			size-1,
			oppvalue[TR_RESULT(result)],
			100-TR_PROB(result));
	}
	rlgotoroot(location);				/* go back to the root, so position is unchanged */
	killist(&path);
	killist(&location);
	prob = 100-TR_PROB(result);
	win = oppvalue[TR_RESULT(result)];
	life(FALSE);
	setvalue(result, prob, win);
	return;
}



/* see if we can make group g live.  return TRUE if have a way to live through reading.
 */
 
int trytolive(group_t g) {
	tree_t movetree;

    g = biggestarmygroup(armygroups[grarmy[g]]);
	if (!foughtalready(g,TRYTOLIVE,grcolor[g],&movetree))
		return FALSE;	/* didn't read it */
	return fireliverules(g, movetree);
	}

/* fire rules to save group g based on movetree */

int fireliverules(group_t g, tree_t movetree) {
	int defc, cutc, ret = FALSE;
	int havewin = FALSE, havelikely = FALSE, haveunknown = FALSE;
	tree_t t;
	sqr_t s = G_KEYPOINT(g);
	int guess = grdefval[g] + gratkval[g];
	int def = grdefval[g];
	int cutval = cut_stones_val(G_ARMY(g));

	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WIN) {
			defc = (def*TR_PROB(t))/100;
			fire_strat_rule(tr[t].s,MAKE_GROUP_LIVE,defc,s,guess);
			if (cutval != 0) {
				cutc = (cutval*TR_PROB(t))/100;
				fire_strat_rule(tr[t].s,SAVE_CUTTING,cutc,s,0);
				}
			ret = TRUE;
			havewin = TRUE;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WINLIKELY) {
			defc = (def*TR_PROB(t))/100;
			if (havewin)
				defc = defc-100;  /* willing to give up 2 points for the certain life */
			fire_strat_rule(tr[t].s,MAKE_GROUP_LIVE,defc,s,guess-def/2);
			if (cutval != 0) {
				cutc = (cutval*TR_PROB(t))/100;
				fire_strat_rule(tr[t].s,SAVE_CUTTING,cutc*4/5,s,0);
				}
			ret = TRUE;
			havelikely = TRUE;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (!tr[t].evaluated) {  /* 5/01 give partial value only if it works, since not actually read */
			defc = (def*tr[t].genval)/100;  /* 3/02 should match unknown formula */
			if (havewin || havelikely)
				defc = (defc*2)/3;
			/* 7/97 can't be urgent in case of bad optimistic static evaluations */
			/* 10/98 need urgent moves of all types if find some */
			fire_strat_rule(tr[t].s,TRY_TO_SAVE,defc,s,def/3);
			continue;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WINKO) {
			haveunknown = TRUE;
			defc = (def*TR_PROB(t))*2/(100*3);
			if (havewin)
				defc /= 2;
			else if (havelikely)
				defc = defc*2/3;
			fire_strat_rule(tr[t].s,MAKE_KO_LIFE,defc,s,def/2 + guess/3);
			if (cutval != 0)
				fire_strat_rule(tr[t].s,SAVE_KO_CUTTING,cutval/3,s,0);
			ret = TRUE;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (tr[t].evaluated && TR_RESULT(t) == V_UNKNOWNRES) {
			haveunknown = TRUE;
			defc = (def*TR_PROB(t))/100;
			if (havewin || havelikely)
				defc = (defc*2)/3;
			fire_strat_rule(tr[t].s,TRY_TO_SAVE,defc,s,def/3+guess/3);
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (tr[t].evaluated && TR_RESULT(t) == V_LOSELIKELY) {
			defc = def*(TR_PROB(t)-40)/100;   /* can be negative */
			if (havewin || havelikely)
				defc = (defc*2)/3;
			if (defc < 0)
				fire_strat_rule(tr[t].s,CANT_LIVE, defc*2,s,0); /* 5/03 should ahve negative value here */
			else if (problemflag != SOLVEPROBLEM && !haveunknown && !havelikely && (ahead < 2)) {
				defc = (((def/2)/10) * TR_PROB(t))/10;
				if (def > 150 && TR_PROB(t) > 10)defc += 150;
				fire_strat_rule(tr[t].s,BEHIND_VITAL,defc,s,0);
				}
			else  /* can't read live, but still good chance */
				fire_strat_rule(tr[t].s,TRY_TO_SAVE,defc,s,0);
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (!tr[t].evaluated && (havewin || havelikely))
			fire_strat_rule(tr[t].s, CANT_LIVE, -def/4, s, 0);
		if (tr[t].evaluated && TR_RESULT(t) == V_LOSE) {
			if (havewin || havelikely || haveunknown)
				fire_strat_rule(tr[t].s,CANT_LIVE,-def,s,0);
			else if (problemflag != SOLVEPROBLEM && (ahead < 2) &&
				TR_RESULT(t) == V_LOSELIKELY)
				fire_strat_rule(tr[t].s,BEHIND_VITAL,def/4,s,0);
			}
		}
	return ret;
	}
	


/* 
 * Fire rules for killing group g based on movetree 
 * return TRUE if found move in tree to kill the group 
 */
int firekillrules(group_t g, tree_t movetree) {
	int atk,atkc,guess,urg,ret = FALSE,cutval, havewin = FALSE, havelikely = FALSE,cutc;
	int haveko = FALSE;
	int haveunknown = FALSE;
	int prob;
	int winatkval = 0;
	sqr_t s;
	tree_t t;	
	s = G_KEYPOINT(g);
	urg = FALSE;
	cutval = cut_stones_val(G_ARMY(g));
	guess = gratkval[g] + grdefval[g];
	atk = gratkval[g];
#ifdef NEVER
	if (G_ALIVE(g) < UNSETTLED_DEAD) {
		guess = atk_val(G_ARMY(g),UNSETTLED_DEAD,0);
		atk = atk_val(G_ARMY(g),UNSETTLED_DEAD,0);
		}
	else
		atk = atk_val(G_ARMY(g),G_ALIVE(g),0);
#endif
	
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WIN) {
			prob = TR_PROB(t);
			prob = 100 - prob;
			prob = prob*prob;
			prob /= 100;
			prob = 100 - prob;  /* push values closer to 100 */
			atkc = ((atk/10)*prob)/10;
			fire_strat_rule(tr[t].s,MAKE_GROUP_DIE,atkc,s,guess);
			winatkval = atkc;
			if (cutval > 0) {
				cutc = ((cutval/10)*prob)/10;
				fire_strat_rule(tr[t].s,KILL_CUTTING,cutc,s,0);
				}
			ret = TRUE;
			if (TR_PROB(t) > 50)
				havewin = TRUE;
			else 
				havelikely = TRUE;
			}
		}

	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WINLIKELY) {
			prob = TR_PROB(t);
			prob = 100 - prob;
			prob = prob*prob;
			prob /= 100;
			prob = 100 - prob;  /* push values closer to 100 */
			atkc = ((atk/10)*prob)/10;
			if (havewin)
				atkc = atkc * 3/4;
			fire_strat_rule(tr[t].s,MAKE_GROUP_DIE,atkc,s,guess);
			if (atkc > winatkval)
				winatkval = atkc;
			if (cutval > 0) {
				cutc = ((cutval/10)*prob)/10;
				if (havewin)
					cutc = cutc*3/4;
				fire_strat_rule(tr[t].s,KILL_CUTTING,cutc,s,0);
				}
			ret = TRUE;
			havelikely = TRUE;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_WINKO) {
			prob = TR_PROB(t);
			prob = 100 - prob;
			prob = prob*prob;
			prob /= 100;
			prob = 100 - prob;  /* 5/01 push values closer to 100 */
			atkc = ((atk/10)*prob)/10;
			haveko = TRUE;
			if (havewin || havelikely)
				atkc /= 2;
			fire_strat_rule(tr[t].s,MAKE_KO_DIE,atkc,s,guess*2/3);
			if (cutval > 0)
				fire_strat_rule(tr[t].s,KO_CUTTING,cutval*2/3,s,0);
			ret = TRUE;
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (tr[t].evaluated && TR_RESULT(t) == V_UNKNOWNRES) {
			haveunknown = TRUE;
			atkc = ((atk/10)*TR_PROB(t))/10;
			if (havewin || havelikely)
				atkc /= 2;
			else if (atk > 250)
				atkc += 150;	/* any attack worth some points */
			fire_strat_rule(tr[t].s,KILL_GROUP2,atkc,s,guess/2);
			}
		if (!tr[t].evaluated) {
			atkc = ((atk/10)*tr[t].genval)/10;
			if (havewin || havelikely)
				atkc /= 2;
			fire_strat_rule(tr[t].s,TRY_TO_KILL,atkc,s,guess/2);
			}
		}
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		if (TR_RESULT(t) == V_LOSE ||
			TR_RESULT(t) == V_LOSELIKELY) {
			if (havewin)
				fire_strat_rule(tr[t].s,CANT_KILL,-winatkval/2,s,0);
			else if (havelikely)
				fire_strat_rule(tr[t].s,CANT_KILL,-winatkval/4,s,0);
			else if (!haveko && !haveunknown)
			{	/* can't read how to kill it - but try anyway - he might make a mistake... */
				atkc = ((atk/20)*TR_PROB(t))/10;  /* half og attack value, since probably ned two moves */
				if (TR_PROB(t) < 25)
					atkc = atk/8;	/* bring it up to at least 1/4 of possible (1/2 of atk) */
				if (atk > 250)
					atkc += 50;
				fire_strat_rule(tr[t].s,TRY_TO_KILL, atkc,s,0);
				}
			}
		}
	return ret;
	}
	
/* read semeai between two armies
 * return TRUE if can win fight
 */

int trytokillnbr(group_t goodgroup,group_t badgroup,int passval,int alpha) {
	int def,atk,size,guess = 0,ret = FALSE,defc;
	int havewin = FALSE, havelikely = FALSE, haveunknown = FALSE;
	sqr_t s;  /* best move that kills neighbor */
	tree_t movetree,t;
	
	s = G_KEYPOINT(goodgroup);
	def = grdefval[goodgroup];
#ifdef NEVER
    atk = atk_val(G_ARMY(badgroup),G_ALIVE(badgroup),0);
#endif
	atk = gratkval[badgroup];

	size = maxlifecalls[playlevel]/8;

	movetree = canbekilled(badgroup,size,maxfightdepth[playlevel]);
	for (t = tr[movetree].child; t != NONE; t = tr[t].sib) {
		if (tr[t].s == NOSQUARE || tr[t].s == PASS)
			continue;
		switch(TR_RESULT(t)) {
			case V_WIN:
				defc = ((def/10)*TR_PROB(t))/10;
				fire_strat_rule(tr[t].s,KILL_TO_LIVE,defc,s,guess);
				ret = TRUE;
				havewin = TRUE;
				break;
			case V_WINLIKELY: 
				defc = ((def/10)*TR_PROB(t))/10;
				if (havewin)
					defc /= 2;
				fire_strat_rule(tr[t].s,KILL_TO_LIVE,defc,s,guess);
				ret = TRUE;
				havelikely = TRUE;
				break;
			case V_WINKO:
				fire_strat_rule(tr[t].s,MAKE_KO_LIFE,(def)/3,s,guess/3);
				ret = TRUE;
				break;
			case V_UNKNOWNRES:
				haveunknown = TRUE;
				defc = ((def/10)*TR_PROB(t))/10;
				if (havewin || havelikely)
					defc /= 2;
				if (defc < 300)
					fire_strat_rule(tr[t].s,ATK_TO_LIVE,defc,s,guess/2);
				else
					fire_strat_rule(tr[t].s,ATK_TO_LIVE,defc,s,guess/2);
				ret = FALSE;
				break;
			case V_LOSE:
			case V_LOSELIKELY:
				if (havewin)
					fire_strat_rule(tr[t].s,CANT_KILL,-def,mvs[grpieces[badgroup]],0);
				else if (havelikely)
					fire_strat_rule(tr[t].s,CANT_KILL,-def/4,mvs[grpieces[badgroup]],0);
#ifdef NEVER
				/* kills off good moves */
				else if (haveunknown)
					fire_strat_rule(tr[t].s,CANT_KILL,-def/4,mvs[grpieces[badgroup]],0);
#endif
				ret = FALSE;
				break;
			}
		}
	return ret;
	
	}

/* mincombinemoves merges common moves and combines their probabilities,
 * using the minimum probability of winning if the same move appears twice
 */

list_t mincombinemoves(list_t *head) {
	int ptr,ptr2,optr;
	int nprob;  /* product of failure probs of additional moves */ 
	list_t changed = EOL;
	
	ASSERT(*head < NUMLIST);
	if (*head == EOL)return(*head);
	for (ptr = *head; link[ptr] != EOL; ptr = link[ptr]) {
		optr = ptr;
		ptr2 = link[ptr];
		nprob = MV_PROB(list[ptr]);	/* 1/2 probability of failing */
		while(ptr2 != EOL) {
			if (MV_MV(list[ptr2]) == MV_MV(list[ptr])) {
				if (MV_PROB(list[ptr2]) > nprob)
					nprob = MV_PROB(list[ptr2]);
				link[optr] = link[ptr2];
				link[ptr2] = freelist;
				freelist = ptr2;
				ptr2 = link[optr];
				}
			else {
				optr = ptr2;
				ptr2 = link[ptr2];
				}
			}
		adflist(MV_MAKE(nprob, MV_MV(list[ptr])),&changed);
		}
	for (ptr = changed; ptr != EOL; ptr = link[ptr]) {
		dellistm(MV_MV(list[ptr]),head,MV_MASK);
		addlist(list[ptr],head);
		}
	killist(&changed);
	return(*head);
	}

/* maxcombinemoves merges common moves and combines their probabilities,
 * using the maximum probability of winning if the same move appears twice
 */

list_t maxcombinemoves(list_t *head) {
	int ptr,ptr2,optr;
	int nprob;  /* product of failure probs of additional moves */ 
	list_t changed = EOL;
	
	ASSERT(*head < NUMLIST);
	if (*head == EOL)return(*head);
	for (ptr = *head; link[ptr] != EOL; ptr = link[ptr]) {
		optr = ptr;
		ptr2 = link[ptr];
		nprob = MV_PROB(list[ptr]);	/* 1/2 probability of failing */
		while(ptr2 != EOL) {
			if (MV_MV(list[ptr2]) == MV_MV(list[ptr])) {
				if (MV_PROB(list[ptr2]) < nprob)
					nprob = MV_PROB(list[ptr2]);
				link[optr] = link[ptr2];
				link[ptr2] = freelist;
				freelist = ptr2;
				ptr2 = link[optr];
				}
			else {
				optr = ptr2;
				ptr2 = link[ptr2];
				}
			}
		adflist(MV_MAKE(nprob,MV_MV(list[ptr])),&changed);
		}
	for (ptr = changed; ptr != EOL; ptr = link[ptr]) {
		dellistm(MV_MV(list[ptr]),head,MV_MASK);
		addlist(list[ptr],head);
		}
	killist(&changed);
	return(*head);
	}


/* combinemoves merges common moves and combines their probabilities,
 * increasing probabilities of winning if the same move appears twice
 * just combine the two best probs
 * GENERIC bug!  the move lists are sorted, so if the same move is generated twice
 * with the same value, it will only appear once, and won't get its value increased.
 * difficult to fix...
 */

list_t combinemoves(list_t *head)
{
	int ptr,ptr2,optr;
	int nprob;  /* product of failure probs of additional moves */ 
	list_t changed = EOL;
	
	ASSERT(*head < NUMLIST);
	if (*head == EOL)return(*head);
	for (ptr = *head; link[ptr] != EOL; ptr = link[ptr]) {
		optr = ptr;
		ptr2 = link[ptr];
		nprob = 50;
		for (ptr2 = link[ptr]; ptr2 != EOL; ptr2 = link[ptr2]) {
			if (MV_MV(list[ptr2]) == MV_MV(list[ptr])) {
				nprob = (49 + nprob * MV_PROB(list[ptr2]))/50;  /* add 49 so rounds properly */
				break;	/* 1/07 only combine top two */
			}
		}
		if (nprob != 50)
			adflist(MV_MAKE((49+nprob*MV_PROB(list[ptr]))/50,MV_MV(list[ptr])), &changed);
	}
	for (ptr = changed; ptr != EOL; ptr = link[ptr]) {
		dellistm(MV_MV(list[ptr]), head, MV_MASK);
		addlist(list[ptr], head);
	}
	killist(&changed);
	return(*head);
}


/* return sorted list of (prob,move) that kill threatened group g 
 * prob is prob of failure 0-50
 */
	
static list_t killthreatened(group_t g) {
	int prob = 0, color;
	list_t tmp = EOL, result = EOL, ptr;
	adthreat(grarmy[g],&tmp,numpotmoves[playlevel]*2);
	if (grthreatened[g] == 1)
		prob = 33;
	tmp = unflist(tmp);
	for (ptr = tmp; ptr != EOL; ptr = link[ptr]) {
		if (iskopoint(list[ptr], &color)) {
			if (list[ptr] == kosquare)
				addlist(MV_MAKE(33,list[ptr]),&result);	
			else
				addlist(MV_MAKE(16,list[ptr]),&result);	
		}
		else 
			addlist(MV_MAKE(prob,list[ptr]),&result);	
		prob += 2;
		}
	killist(&tmp);
	return(result);
	}	


/* return an unsorted list of moves to make group g die.
 * points in list are ordered from best move to worst
 * each must have >= probability of success than prob (0-100)
 */     
     
list_t justkillmoves(group_t g, int prob) {
	list_t tmp, ptr, tmp2 = EOL;
	
	tmp = killmoves(g);
	for (ptr = tmp; ptr != EOL; ptr = link[ptr]) {
		if (100-MV_PROB(list[ptr])*2 < prob)
			break;
		aeflist(MV_MV(list[ptr]), &tmp2);  /* strip off probabilities */
		}
	killist(&tmp);
	return tmp2;	
	}

/* get the peak number of eye possible for army.  brun is best run value */

static int getpeakeyes(army_t army, int brun) {
	int peak, runpeak;
	peak = armyeyespace[army] + armybestpot[army] + armysecond[army] + armyrest[army]/2 + armypthreat[army]/2;
	runpeak = armyrn_pot[army] + newrunval[brun] + armycnrn_pot[army];
	if (runpeak > MAXRUNEYES-1)
		runpeak = MAXRUNEYES-1;
	peak += runeyes[runpeak];
#ifdef NEVER	
	runpeak = armyeyespace[army] + armyrest[army]/2 + runeyes[runpeak];
	if (runpeak > peak)
		peak = runpeak;
#endif		
	return peak;
	}

/* find moves to kill group g. may return illegal ko capture moves */

list_t killmoves(group_t g) {
	list_t moves = EOL, semmoves = EOL, tmplist = EOL, ptr, ptr2, ptr3, moves2 = EOL;

	int bpot, bpotv = -1, val, brun, i, count = 0, adcount;
	int peakeyes, runtype, eyecount;
	int prob;
	
	army_t army;
	
	if (g == NOGROUP) {
#ifdef CHECK
		outerror("killife called with NOGROUP\n");
#endif		
		return EOL;
	}
	
	army = G_ARMY(g);

	semmoves = killsem(g);
	if (semalive[G_ALIVE(g)] || G_ALIVE(g) > ALIVE && armyrn_pot[army] <= 2 && armybestpot[army] <= 4 && armyeyespace[army] <= 8)
		return semmoves;  /* kill group in semeai */

	brun = NUMRUN-1;
	for (i = 0; i < NUMRUN; ++i)  /* find best running value */
		if (armyrun[army][i] != EOL) {
			brun = i;
			break;
		}
	
	peakeyes = getpeakeyes(army,brun);
	
    /* first do eye killing moves - find best eye potential*/
	for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
		if (pots[list[ptr]].pot_type == UNDERCUT ||
			pots[list[ptr]].pot_type == EXTEND) {
			if (pots[list[ptr]].pot_val == 0)continue;
			val = pots[list[ptr]].pot_val + 2;  /* for killing, try enclosing moves first */
			val = sumeyes[val];
		}
		else 
			val = (pots[list[ptr]].pot_max+pots[list[ptr]].pot_val)/2;
		if (val > bpotv) {
			bpotv = val;
			bpot = list[ptr];
		}
	}
	count = 0;
	if (bpotv != -1) {
#ifdef NEVER
		for (ptr = armyeyerecs[army]; ptr != EOL; ptr = link[ptr])
			if (eyetype[list[ptr]] == THRTEYE)
				addlist(list[ptr], &savethreateye);
#endif
		for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
			if (pots[list[ptr]].pot_type == UNDERCUT ||
				pots[list[ptr]].pot_type == EXTEND) {
				if (pots[list[ptr]].pot_val == 0 &&
					pots[list[ptr]].pot_type == EXTEND)continue;
						/* need to allow val==0 undercuts for surrounding groups near the edge */
				val = pots[list[ptr]].pot_val;
				if (val != 0)
					val += 2;  /* prefer to enclose first */
				val = sumeyes[val];
			}
			else 
				val = (pots[list[ptr]].pot_max + pots[list[ptr]].pot_val)/2;
			if (val == bpotv ||
				val >= bpotv-12 && bpotv <= 20 || 
				val + armyeyespace[army] >= 16 || val >= 8 ||
				eyetype[list[ptr]] == THRTEYE) {  /* always look at saving threatened group */
				tmplist = rmpot(army,list[ptr]);
				adcount = 0;
				for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
					prob = killeyeprob(army,peakeyes,val,adcount);
					if (pots[list[ptr]].pot_type == POTTHREAT) {
						if (list[ptr2] == kosquare)
							prob = 50-(50-prob)/3;	/* 5/01 1/3 chance of success to win ko */
						else
							prob = 50-(50-prob)/2;
					}
					if (inlistm(list[ptr2], &moves, MV_MASK)) {  /* replace it if it's better */
						for (ptr3 = moves; ptr3 != EOL; ptr3 = link[ptr3]) {
							if (MV_MV(list[ptr3]) == list[ptr2]) {
								if (prob < MV_PROB(list[ptr3])) {
									dellistm(list[ptr2], &moves, MV_MASK);
									addlist(MV_MAKE(prob, list[ptr2]), &moves);
									adcount += 3;
								}
								break;
							}
						}
					}
					else {  /* new move */
						addlist(MV_MAKE(prob, list[ptr2]),&moves);
						adcount += 3;
					}
				}
				killist(&tmplist);
			}
#ifdef NEVER
				/* values are for making life, not killing, so gen lots */
				if (val > best2)best2 = val;
				tmplist = rmpot(army,list[ptr]);
				mrflist(&tmplist,&moves2,count2);
				count2++;
			}
#endif				
		}
		}
#ifdef NEVER
	if (bpotv >= 24)
		killist(&runmoves);  /* don't surround if can live */
	else if (bpotv+armyeyespace[army] >= 16)
		mrflist(&runmoves,&moves,3);  /* surounding moves after eye making moves */
	else
		catlist(&runmoves,&moves);  /* surrounding moves before eye making moves */
	if (best2 == 0 && armyrn_pot[army] <= 3)adflist(PASS,&moves2);  /* try pass before no value moves */
	mrflist(&moves2,&moves,4);
	mrflist(&weakrunmoves,&moves,5);
#endif	
	if (armykillmove2[army] != NOSQUARE) {  /* see if have better value here */
		for (ptr = moves; ptr != EOL; ptr = link[ptr]) {
			if (MV_MV(list[ptr]) == armykillmove2[army]) {
				if (MV_PROB(list[ptr]) > killeyeprob(army,peakeyes,armybestpot2[army],1)) {
					dellistm(armykillmove2[army],&moves,MV_MASK);
					addlist(MV_MAKE(killeyeprob(army,peakeyes,armybestpot2[army],1), armykillmove2[army]), &moves);
				}
				break;
			}
		}
		if (ptr == EOL) {  /* make sure this move is entered */
			addlist(MV_MAKE(killeyeprob(army,peakeyes,armybestpot2[army],1), armykillmove2[army]), &moves);
		}
	}
	if (armykillmove[army] != NOSQUARE) {
		dellistm(armykillmove[army], &moves, MV_MASK);
		addlist(MV_MAKE(killeyeprob(army,peakeyes,armybestpot[army],0), armykillmove[army]), &moves);  /* 7/01 -1 to make sure it's in front */
	}
    if (armyrn_pot[army] < LIMP_RUN && peakeyes < 24)
    	addlist(MV_MAKE(killeyeprob(army,peakeyes,0,10),PASS),&moves);  /* may be already dead */

#ifdef NEVER
	/* make sure the saving move for the group is in the move list */
	/* rmpot should already do this.  this code double counts */
	for (ptr = savethreateye; ptr != EOL; ptr = link[ptr]) {
		val = armybestpot[army];
		if (val > 5)
			val = val - 5;
		if (grsavemove[board[list[eyeptr[list[ptr]]]]] != NOSQUARE)
			addlist(MV_MAKE(killeyeprob(army,peakeyes,val,0), grsavemove[board[list[eyeptr[list[ptr]]]]]), &moves);
	}
	killist(&savethreateye);
#endif

    for (runtype = brun; runtype < NUMRUN; runtype++) {
		for (ptr = armyrun[army][runtype]; ptr != EOL; ptr = link[ptr]) {
			tmplist = surroundpoints(army,list[ptr]);
			adcount = 0;
			for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
				addlist(MV_MAKE(killrunprob(army,peakeyes,runtype,adcount, list[ptr2]),list[ptr2]),&moves);
				adcount += 2;
				}
			killist(&tmplist);
			}
		if (bpotv >= 8 && runtype > brun)
			break;  /* only two runtypes if he can make eye */
	}
				
	if (G_THREATENED(g)) {
		moves2 = killthreatened(g);
		mrglist(moves2,&moves);  /* put capture moves in front */
		killist(&moves2);
	}
	/* attack a single very big eye */
	if (armyrn_pot[army] == 0 && armyeyes[army] >= 16) {
		eyecount = 0;
		for (ptr = armyeyerecs[army]; ptr != EOL; ptr = link[ptr])
			if (eyepot[list[ptr]] >= 8)
				eyecount++;
		if (eyecount == 1) {	/* all eyespace is in one eye */
			for (ptr = armyeyerecs[army]; ptr != EOL; ptr = link[ptr])
				if (eyepot[list[ptr]] >= 8)
					for (ptr2 = eyevital[list[ptr]]; ptr2 != EOL; ptr2 = link[ptr2])
						addlist(MV_MAKE(47, list[ptr2]), &moves);
		}
	}
	tmplist = combinemoves(&moves);
	/* combine semmoves and life moves.  pick the largest value for each move, and add semmoves missing from the list */
	if (G_ALIVE(g) >= UNSETTLED_DEAD) {
		for (ptr = semmoves; ptr != EOL; ptr = link[ptr]) {
			if (!inlistm(MV_MV(list[ptr]), &tmplist, MV_MASK)) {
				addlist(list[ptr], &tmplist);
			}
		}
	}
	killist(&semmoves);
	return tmplist;
}
     
/* return a list of moves to make group g live */     
     
list_t justlifemoves(group_t g) {
	list_t tmp, ptr;
	
	tmp = lifemoves(g);
	for (ptr = tmp; ptr != EOL; ptr = link[ptr])
		list[ptr] = MV_MV(list[ptr]);  /* strip off probabilities */
	return tmp;	
	}

list_t justlifesetmoves(list_t groups) {
	list_t tmp, ptr;
	
	tmp = lifesetmoves(groups);
	for (ptr = tmp; ptr != EOL; ptr = link[ptr])
		list[ptr] = MV_MV(list[ptr]);  /* strip off probabilities */
	return tmp;	
	}

/* return a list of (prob, move)'s to make a set of groups live.
 */

list_t lifesetmoves(list_t groups) { 
	list_t armylist = EOL, moves, movelist = EOL, ptr;
	
	for (ptr = groups; ptr != EOL; ptr = link[ptr])
		if (grlv[list[ptr]]) {
			addlist(G_ARMY(list[ptr]),&armylist);
			}
		else if (S_COLOR(mvs[grpieces[list[ptr]]]) == G_COLOR(list[ptr]))
			addlist(S_ARMY(mvs[grpieces[list[ptr]]]), &armylist);  /* group combined and changed number */

	for (ptr = armylist; ptr != EOL; ptr = link[ptr]) {
		moves = lifemoves((group_t)list[armygroups[list[ptr]]]);
		mrglist(moves,&movelist);  /* todo - problem since removes duplicates */
		killist(&moves);
		}
	killist(&armylist);
	maxcombinemoves(&movelist); 
	return movelist;
	}
              
/* return a list of (prob, move)'s to make group g live.  If group g is in a fight,
 * includes moves to capture neighboring group with highest probability
 * of capture.
 */
               
list_t lifemoves(group_t g)
{
	list_t moves = EOL, livemoves = EOL, ptr, semgroups, semmoves;
	int prob;
	int eyes, maxeyes, thprob;
	group_t bestgroup;
	
	if (g == NOGROUP) {
#ifdef CHECK
		outerror("lifemoves called with NOGROUP\n");
#endif	
		return EOL;
	}
	
	if (/* semalive[G_ALIVE(g)] || G_ALIVE(g) == WEAK_POTENTIAL */
		G_ALIVE(g) >= STRONG_SEMEAI && G_ALIVE(g) <= WEAK_POTENTIAL ) {
		/* always look at killing a neighbor */
		semgroups = weaksemneighbors(grarmy[g]);
		prob = 50;
		while (semgroups != EOL && prob > 0) {
			bestgroup = weakestnbr(semgroups);  /* find best cantidate */
			if (!dlflist(bestgroup, &semgroups)) {
				break;	/* should never happen, but just in case... */
			}
			if (bestgroup == NOGROUP) {
				continue;
			}
			semmoves = getsemeaimoves(g, bestgroup);
			eyes = eyesifcapture(grarmy[bestgroup], grarmy[g], &maxeyes);
			/* adjust values if don't make two eyes */
			if (maxeyes < 16) {	/* 5/01 be optimistic here for good move ordering */
				prob = 50-geteyeprob(grarmy[g], eyes, maxeyes, 0);
			}
			for (ptr = semmoves; ptr != EOL; ptr = link[ptr]) {
				list[ptr] = MV_MAKE(50 - prob * (50 - MV_PROB(list[ptr])) / 50, MV_MV(list[ptr]));
			}
			/* semmoves is no longer sorted */
			for (ptr = semmoves; ptr != EOL; ptr = link[ptr]) {
				addlist(list[ptr], &moves);
			}
			killist(&semmoves);
		} 
		combinemoves(&moves);  /* allow moves to try to kill two neighbors */
		livemoves = makelife(g);
		mrglist(livemoves, &moves);
		killist(&livemoves);
		killist(&semgroups);
		maxcombinemoves(&moves);  /* take best of semeai moves or living moves */
	}
	else {
		moves = makelife(g);
   	}
	if (grthreatened[g]) {  /* try any move that might save group */
		livemoves = getdefmoves(g);
		thprob = 50 - lifeprob[armyeyes[G_ARMY(g)]];
		for (ptr = livemoves; ptr != EOL; ptr = link[ptr]) {
			if (list[ptr] != PASS && !inlistm(list[ptr], &moves, MV_MASK)) {
				addlist(MV_MAKE(grthreatened[g] == 2 ? thprob : thprob, list[ptr]), &moves);  /* 5/01 if pthreat, less likely moves will work */
			}
		}
		killist(&livemoves);
   	}
	/* make sure that all moves tried leave the group unthreatened 
	 * (including effects of ko)  This quick check can eliminate
	 * a lot of stupid reading later.
	 */
	combinemoves(&moves);

	return moves;
}              

/* find moves that make eye shape, but are not eyepot moves.  return plain list of moves */

static list_t getweakeyemoves(army_t army) {
	list_t moves = EOL, ptr, ptr2;
	int c;
	c = A_COLOR(army);
	for (ptr = armylbp[army]; ptr != EOL; ptr = link[ptr]) {
		if (lnbf[list[ptr]][c] == 2 && lnbf[list[ptr]][1-c] == 0) {
			for (ptr2 = nblbp[list[ptr]]; ptr2 != EOL; ptr2 = link[ptr2]) {
				if (lnbn[list[ptr2]] == 4)
					addlist(list[ptr2],&moves);
				}
			}
		}
	return moves;
	}

static int getrunprob(army_t a, int val, int count) {
	int prob;
	int run;
	int eyes;
	int best = armybestpot[a];
	if (newrunval[val] < best)	/* after I run, opponent chosses if I get best or another run */
		best = newrunval[val];
	
	run = armyrn_pot[a] + newrunval[val];
	if (run > MAXRUNEYES-1)
		run = MAXRUNEYES - 1;
	/* add up eyes from running and eyespace, and add extra running */
	eyes = armyeyespace[a] + runeyes[run] + best;  /* 3/02 can get bestval or a second run, whichever is smaller! */
	if (eyes >= MAXLIFE)
		eyes = MAXLIFE-1;
	prob = lifeprob[eyes];
	prob -= count;
	if (prob < 0)
		prob = 0;
	return 50-prob;
	}


/* find probability of making two eyes for army if army gets 
 * val extra eye space.  return 0-50, with 0 being 100% certain
 * life and 50 being 100% certain death.
 */

static int geteyeprob(army_t a, int val, int maxval, int count) {
	int prob;
	int eyes, eyes1;
	
	/* add up eyes from running and eyespace, and add val */
	eyes = armyeyespace[a]+runeyes[armyrn_pot[a]]+val;
	if (val == 0 && eyes > 4)
		eyes -= 4;	/* reduced value for worthless move */
	eyes1 = eyes+maxval-val;
	if (eyes >= MAXLIFE)
		eyes = MAXLIFE-1;
	if (eyes1 >= MAXLIFE)
		eyes1 = MAXLIFE-1;
	prob = (lifeprob[eyes] + lifeprob[eyes1])/2;
	prob -= count;
	if (prob < 0)
		prob = 0;
	if (prob > 50)
		prob = 50;
	return 50-prob;
	}
    
/* return prob of failing to kill army.  peakeyes is max eyes army can
 * get with any move.  val is eye potential removed by this move.
 * count should be added to failure probability
 */    
    
static int killeyeprob(army_t army, int peakeyes, int val, int count)
{
	int eyes, prob;
	eyes = peakeyes - val;
	if (eyes >= MAXLIFE)
		eyes = MAXLIFE-1;
	if (eyes < 0)
		eyes = 0;
	prob = lifeprob[eyes];  /* life propability is prob of failing to kill */
	prob += count;
	if (prob > 50-val/4)
		prob = 50-val/4;   /* make sure result is sorted by number of eyes removed, even if still lives */
	if (prob > 49)
		prob = 49;
	if (prob > 48 && val > 0)
		prob = 48;
	if (prob < 0)
		prob = 0;
	return prob;
}

/* failure prob of killing army by eliminating a runing move */

static int killrunprob(army_t army, int peakeyes, int val, int count, sqr_t s) {
	int prob;
	int run;
	int eyes;
	
	run = newrunval[val];
	eyes =  peakeyes - runeyes[run];
	if (eyes >= MAXLIFE)
		eyes = MAXLIFE-1;
	if (eyes < 0)
		eyes = 0;
	prob = lifeprob[eyes];
	prob += count;
	if (eyes < 16)  /* to choose best move direction.  If there are lots of eyes, this adjustment 
				    * makes running moves look too good. */
		prob -= (MAXRTVAL-rterv[s][1-A_COLOR(army)])/15;
	if (prob > 49)
		prob = 49;
	if (prob < 0)
		prob = 0;
	return prob;
	}

              
/* return a list of (prob,move)'s to make group g alive.  Best move first.
 * prob is prob of move failure, so addlist sort will work.
 * might include illegal ko capture. Only returns eye making moves for
 * this group.
 */
	
static list_t makelife(group_t g) {
	list_t moves = EOL, tmplist = EOL, ptr, ptr2;
	int runtype, bpot,bpotv = -1,val, mval, brun,i, count = 0, adcount, prob, minpotv = -1;
	army_t army;
	int maxval;
	
	if (g == NOGROUP) {
#ifdef CHECK
		outerror("makelife called with NOGROUP\n");
#endif	
		return EOL;
		}
	army = G_ARMY(g);

	/* find best running value */

	brun = NUMRUN-1;
	for (i = 0; i < NUMRUN; ++i)  /* find best running value */
		if (armyrun[army][i] != EOL) {
			brun = i;
			break;
			}
    
                                                                          
	/* first do eye making moves */

	for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
		if (pots[list[ptr]].pot_type == UNDERCUT ||
			pots[list[ptr]].pot_type == EXTEND) {
			val = sumeyes[pots[list[ptr]].pot_val];
			mval = val;
			}
		else {
			val = (pots[list[ptr]].pot_val+pots[list[ptr]].pot_max)/2;
			mval = pots[list[ptr]].pot_val;
			}
		if (val > bpotv) {
			bpotv = val;
			bpot = list[ptr];
			}
		if (mval > minpotv)
			minpotv = mval;
		}

	/* bpotv has the value of the best maximum eye potential */
	count = 0;	
	if (bpotv != -1) { 
		for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
			if (pots[list[ptr]].pot_type == UNDERCUT ||
				pots[list[ptr]].pot_type == EXTEND) {
				/* if (pots[list[ptr]].pot_val == 0)continue; tried to add more moves, 9/22/96 */
				val = sumeyes[pots[list[ptr]].pot_val];
				maxval = val;
				}
			else  {
				val = (pots[list[ptr]].pot_val+pots[list[ptr]].pot_max)/2;
				maxval = pots[list[ptr]].pot_max;
				}
			
			if (val >= bpotv ||     /* 1/10/99 allow val == 0 */
				val >= minpotv-8 && (val >= 0 || !A_THREATENED(army)) ||
				val + armyeyes[army] >= 8 ||	/* 1/10/99, changed 16 to 8 */
				val >= 8 ||
				bpotv+armyeyes[army] < 24 && val >= 4) {
				if (playlevel > 2 && 
					(pots[list[ptr]].pot_type == THREAT ||
					pots[list[ptr]].pot_type == POTTHREAT))  /* get all moves */
					adthreat((army_t)pots[list[ptr]].pot_where,&tmplist,numpotmoves[playlevel]*2);
				else 
					tmplist = adpot(army,list[ptr]);
				adcount = 0;
				for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
					prob = geteyeprob(army, val, maxval, adcount);
					if (pots[list[ptr]].pot_type == POTTHREAT) {
						if (list[ptr2] == kosquare)
							prob = 50-(50-prob)/3;	/* 5/01 1/3 chance of success to win ko */
						else
							prob = 50-(50-prob)/2;
						}
					addlist(MV_MAKE(prob,list[ptr2]),&moves);
					adcount += 3;
					}
				killist(&tmplist);
				}
			}
		}

	if (bpotv < 8) { /* if no good eye moves, try for shape at least */
		tmplist = getweakeyemoves(army);
		for (ptr = tmplist; ptr != EOL; ptr = link[ptr])
			addlist(MV_MAKE(30,list[ptr]),&moves);
		killist(&tmplist);
		}
	if (armysecondmove[army] != NOSQUARE) {
		dellistm(armysecondmove[army],&moves,MV_MASK);
		addlist(MV_MAKE(geteyeprob(army, armysecond[army], armysecond[army], 1), armysecondmove[army]), &moves);
		}
	if (armybestmove2[army] != NOSQUARE) {  /* put best moves to front of list */
		dellistm(armybestmove2[army],&moves,MV_MASK);
		addlist(MV_MAKE(geteyeprob(army, armybestpot2[army], armybestpot2[army], 0), armybestmove2[army]), &moves);
		}
	if (armybestmove[army] != NOSQUARE) {  /* put best moves to front of list */
		dellistm(armybestmove[army],&moves,MV_MASK);
		addlist(MV_MAKE(geteyeprob(army, armybestpot[army], armybestpot[army], -1), armybestmove[army]), &moves);
		}


	/* now do running moves */

    for (runtype = brun; runtype < NUMRUN; runtype++) {

		for (ptr = armyrun[army][runtype]; ptr != EOL; ptr = link[ptr]) {
			tmplist = runpoints(army,list[ptr], runtype);
			adcount = 0;
			for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
				addlist(MV_MAKE(getrunprob(army,runtype,adcount),list[ptr2]),&moves);
				adcount += 2;
				}
			killist(&tmplist);
			}
		}
#ifdef NEVER
	if (brun <= 12) {  /* get the running moves */
		for (ptr = armyrun[army][brun+1]; ptr != EOL; ptr = link[ptr]) {
			tmplist = runpoints(army,list[ptr],brun+1);
			adcount = 0;
			for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
				addlist(MV_MAKE(getrunprob(army,brun+1,adcount),list[ptr2]),&moves);
				adcount += 3;
				}
			killist(&tmplist);
			}
		}
#endif

	/* now to save threaatened group */

	if (A_THREATENED(army) && grsavemove[list[armygroups[army]]] != NOSQUARE) {
/*		dellistm(grsavemove[list[armygroups[army]]],&moves,MV_MASK);   10/96 just make this move more likely.  deleting it and puttinig it back could move it down in ranking */
		addlist(MV_MAKE(A_THREATENED(army)==2?40:45,grsavemove[list[armygroups[army]]]),&moves);
		}
		
	return(combinemoves(&moves));
	}           
	

/* did goodgroup kill badgroup - badgroup must die to win */

int semgoodresult(group_t goodgroup, group_t badgroup) {
	if (badgroup == NOGROUP)
		return(GOODWINS);  /* captured group */
	else if (G_ALIVE(badgroup) >= WEAK)
		return(GOODWINS);
	else if (G_ALIVE(badgroup) >= WEAK_SEMEAI)
		return(GOODLIKELY);		
	else if (G_ALIVE(badgroup) <= ALIVE || livealive[G_ALIVE(badgroup)])
		return(LOSEFIGHT);
	else return(GOODUNKNOWN);
	}

	
int sembadresult(group_t goodgroup, group_t badgroup) {
	if (badgroup == NOGROUP)
		return(BADWINS);
	if (G_ALIVE(goodgroup) <= ALIVE || G_ALIVE(badgroup) >= WEAK)
		return(BADWINS);
	else if (G_ALIVE(badgroup) <= ALIVE || livealive[G_ALIVE(badgroup)])
		return(LOSEFIGHT);
	else return(BADUNKNOWN);
	}

/* trying to live.  did my last move make life? */
	
int liveresult(group_t goodgroup, group_t badgroup)
{
	badgroup = badgroup;
	if (!grlv[goodgroup])
		return LOSEFIGHT;
	if (goodgroup == NOGROUP)
		return LOSEFIGHT;
	if ((G_ALIVE(goodgroup) == MIAI || G_ALIVE(goodgroup) == BARELY_ALIVE) &&
			armyrn_pot[G_ARMY(goodgroup)] < 8 &&
			playlevel > 2)
		return GOODLIKELY;
	else if (G_ALIVE(goodgroup) <= ALIVE)
		return GOODWINS;
	else if (G_ALIVE(goodgroup) == STRONG_SEMEAI || 
		armyrn_pot[G_ARMY(goodgroup)] >= 10)
		return GOODLIKELY;
	else if (!G_THREATENED(goodgroup) &&
		(armyeyespace[G_ARMY(goodgroup)] + armyrn_pot[G_ARMY(goodgroup)] >= 16))
		return GOODWINS;  /* no point in reading further, this group will get away */
	else if (G_ALIVE(goodgroup) == STRONG_KO)
		return KORESULT;
	else if (G_ALIVE(goodgroup) >= WEAK)
		return LOSEFIGHT;
	else if (G_ALIVE(goodgroup) == WEAK_POTENTIAL && 
		(armyeyespace[G_ARMY(goodgroup)]+armysecond[G_ARMY(goodgroup)] <= 8 ||  /* 8/02 must have no potential for second eye */
		 armyeyespace[G_ARMY(goodgroup)] <= 8 && armybestpot[G_ARMY(goodgroup)] <= 4 && gralprob[goodgroup] <= -45)) /* 7/03 */
		/* 7/99 WEAK_POTENTIAL since enemy moves now - no way can live */
		return LOSEFIGHT;
	else if (G_ALIVE(goodgroup) >= WEAK_KO || 
		G_ALIVE(goodgroup) == UNSETTLED_DEAD &&
		armyeyespacemax[G_ARMY(goodgroup)] < 16 || 
		G_THREATENED(goodgroup)) 
		return LOSELIKELY;
	else 
		return GOODUNKNOWN;
}


/* trying to prevent life.  did my last move kill goodgroup */	

int stopliveresult(group_t goodgroup, group_t badgroup) {

	badgroup = badgroup;
	if (goodgroup == NOGROUP)
		return(BADWINS);
	if (G_ALIVE(goodgroup) >= WEAK)
		return(BADWINS);
	else if (G_ALIVE(goodgroup) > SEMEAI)
		return(BADLIKELY);
	else if (G_ALIVE(goodgroup) <= VERY_ALIVE)
		return(LOSEFIGHT);
	else if (G_ALIVE(goodgroup) <= ALIVE)
		return(LOSELIKELY);
	else return(BADUNKNOWN);
	}


/* trying to kill group.  did my last move kill it */	

int killresult(group_t goodgroup, group_t badgroup) {

	badgroup = badgroup;
	if (!grlv[goodgroup])
		return GOODWINS;
	if (goodgroup == NOGROUP)
		return GOODWINS;
	if (G_ALIVE(goodgroup) >= WEAK)
		return GOODWINS;
	if (G_ALIVE(goodgroup) == STRONG_KO || 
	   G_ALIVE(goodgroup) == UNSETTLED_LIMP ||
	   G_ALIVE(goodgroup) == STRONG_SEMEAI ||
	   armyrn_pot[G_ARMY(goodgroup)] >= 7)
		return LOSELIKELY;
	else if (G_ALIVE(goodgroup) <= ALIVE)
		return LOSEFIGHT;
	else if (G_ALIVE(goodgroup) == WEAK_KO)
		return KORESULT;
	else if (G_ALIVE(goodgroup) > WEAK_LIMP && 
		armyrn_pot[G_ARMY(goodgroup)] <= 3)
		return GOODLIKELY;
	else 
		return GOODUNKNOWN;
}


/* trying to prevent killing.  did my last last move save it */
	
int stopkillresult(group_t goodgroup, group_t badgroup)
{
	badgroup = badgroup;
	if (goodgroup == NOGROUP)
		return LOSEFIGHT;
	if ((G_ALIVE(goodgroup) == MIAI || G_ALIVE(goodgroup) == BARELY_ALIVE) &&
		playlevel > 2)
		return BADLIKELY;
	else if (G_ALIVE(goodgroup) <= ALIVE)
		return BADWINS;
	else if (G_ALIVE(goodgroup) > WEAK)
		return LOSEFIGHT;
	else if (G_ALIVE(goodgroup) >= WEAK_POTENTIAL)
		return LOSELIKELY;
	else return BADUNKNOWN;
}


/* find moves and sort by value for fighting a semeai.
 * return sorted list of (prob,move)  goodgroup's turn to move
 * prob is prob of failure (0-50)
 * value is 8 per liberty gained or removed
 * Note that goodgroup can be NOGROUP - just attack badgroup!
 * Can return PASS
 */
    
static list_t getsemeaimoves(group_t goodgroup, group_t badgroup) {
	int bval,bmv = 0,i,nbminlibs,nbmaxlibs,j,prob;
	int maxlibs,minlibs,nbal,nbcomlibs,libsneeded;
	int best,typlibs,nbtyplibs;
	int hemin,hemax,memin,memax;
	int nbhemin,nbhemax,nbmemin,nbmemax;
	int atkval = 0;  /* bonus for attack enemy rather than defend me */
	
	list_t movelist = EOL;
	army_t army,nbarmy;

	if (G_THREATENED(badgroup))  /* can capture neighbor */
		movelist = killthreatened(badgroup);  /* was just return here */
						/* should allow more moves generated */
	mptr = 0;
	army = G_ARMY(goodgroup);  /* army could be NOARMY! */
	nbarmy = G_ARMY(badgroup);
	if (army != NOARMY) {
		semeailibs(army,&minlibs,&maxlibs,&typlibs,&hemin,&hemax,&memin,&memax);
		nbcomlibs = comlist(armylbp[nbarmy],armylbp[army]);
	}
	else {
		minlibs = maxlibs = typlibs = 20;
		nbcomlibs = 3;  /* high so will concentrate on killing eyes */
	}
	semeailibs(nbarmy,&nbminlibs,&nbmaxlibs,&nbtyplibs,&nbhemin,&nbhemax,&nbmemin,&nbmemax);
		
	if (armyeyespace[nbarmy] < 8) {
		nbminlibs -= nbcomlibs;
		nbmaxlibs -= nbcomlibs;
		nbtyplibs -= nbcomlibs;
	}
	if (army != NOARMY && armyeyespace[army] < 8) {
		minlibs -= nbcomlibs;
		maxlibs -= nbcomlibs;
		typlibs -= nbcomlibs;
	}
	if (nbmaxlibs < 2)
		nbmaxlibs = 2;
	if (nbminlibs < 1)
		nbminlibs = 1;
	if (nbtyplibs < 1)
		nbtyplibs = 1;
	libsneeded = nbmaxlibs-minlibs+1;  /* need one more liberty than he has */ 
	nbal = A_ALIVE(nbarmy);
	if (goodgroup == NOGROUP || G_THREATENED(goodgroup) != 2 || G_NUMLIBS(badgroup) <= 2)  /* 8/99 have to save myself first 3/04 unless enemy is short of liberties */
		semkillsem(army,nbarmy,0,nbcomlibs,nbtyplibs,nbmaxlibs);   /* kill eyes and fill liberties */

       /* attack opponent by increasing my minimum liberties.
	   value by how many more minimum libs I get */
	atkval = (typlibs - nbtyplibs) * LIBVALUE/4;  /* if ahead, prefer to kill him */
	   		/* better to attack group we can beat in fight */
	if (atkval > 0)atkval = 0;
	if (army != NOARMY && libsneeded > -2 && typlibs < nbmaxlibs+3)
		makaneye(army,nbarmy,-atkval,nbcomlibs);    
		/* no point in increasing liberties if already have enough */
	if (army != NOARMY && libsneeded > 0) {
		if (armyrn_pot[army] <= 3)  /* don't get liberties if can run away */
			getmorelibs(army,nbarmy,0,TRUE);
		/* semrun(army, 0);   no need to run army since running moves generated elsewhere */
	}
	if (mptr == 0)	/* 2/02 don't make garbage move when no moves generated */
		return movelist;
	best = SMALLNUM;
	j = 0;
	do {
		bval = SMALLNUM;
		for (i = 0; i < mptr && i < NUMSEMMOVES; ++i)	/* use the best values only when there are duplicates */
			if (sem_val[i] > bval) {
				bval = sem_val[i];
				bmv = i;
				}
		if (bval > best)best = bval;
		if (bval == SMALLNUM || bval < best-maxsemdiff[playlevel] && j > 4)break;
		for (i = 0; i < mptr && i < NUMSEMMOVES; ++i) {	/* handle duplicates */
			if (i != bmv && sem_moves[i] == sem_moves[bmv]) {
				sem_val[i] = SMALLNUM;
			}
		}
		if (army == NOARMY) {
			prob = (nbmaxlibs*LIBVALUE-sem_val[bmv]);
			if (prob < LIBVALUE)
				prob = LIBVALUE;
			prob = prob*50/(nbmaxlibs*LIBVALUE);
			if (prob < 1)prob = 1;
			if (prob > 49)prob = 49;
		}
		else {
			prob = 40-winsemprob(army,nbarmy,sem_val[bmv],0)*4/10;  /* add j to maintain order if probs are same */
			prob += j*3;  /* 5/01 use 40 to maintain order */
			if (prob > 50)
				prob = 50;
		}
		/* if (prob < 50) 5/01 - winsemprob can return 0, but group can still live with this move due to making seki */
			
		addlist(MV_MAKE(prob,sem_moves[bmv]),&movelist);
		savesemmoves[j] = sem_moves[bmv];
		savesemval[j++] = bval;
		if (j > 6 && prob == 50)
			break;  /* don't generate a bunch of worthless moves */
		sem_val[bmv] = SMALLNUM;
	} while(bval > 0);  /* only allow one move <= 0 */	
	savesemmptr = j;
	return(movelist);
}



#ifdef G2DEBUGOUTPUT

void debugsemmoves(sqr_t cursorpos, int tm) {
	group_t g1;
	sqr_t cp2;
	int gl, alprob, semprob, min, max;
	char buf[200];

	g1 = S_GROUP(cursorpos);
	if (g1 == NOGROUP) {
		outerr("Cursor must be on a group");
		return;
	}
	higroup(g1);
	clearerror();
	outerr("Friendly group marked\n");
	outerr("Click on enemy group for semeai or same group for life/death\n");
	cp2 = waitclick();
	unhighlight();
	if (S_GROUP(cursorpos) == NOGROUP) {
		outerr("must click on a group");
		return;
	}
	gl = uns_semeai(S_ARMY(cursorpos), &alprob, &semprob, &min, &max);
	sprintf(buf, "Life %d, alprob %d, semprob %d, min eyes %d, max eyes %d\n", gl, alprob, semprob, min, max);
	outerr(buf);
	outsemmoves(cursorpos, cp2, tm);
}

#endif

#ifndef SMALLCODE

void outsemmoves(sqr_t cp1, sqr_t cursorpos, int tm)
{
	list_t tmp, ptr, nbr, tmp2;
	int i = 1, alprob, semprob, lf;
	int min, max;
#ifdef G2DEBUGOUTPUT
	tree_t movetree;
	int eyes, maxeyes;
#endif
	group_t g1;
	char buf[200],buf2[60],buf3[60];

	g1 = S_GROUP(cp1);
    g1 = biggestarmygroup(armygroups[grarmy[g1]]);
	
	life(FALSE);
	if (S_ARMY(cursorpos) == G_ARMY(g1)) {
		lf = uns_semeai(grarmy[g1], &alprob, &semprob, &min, &max);
#ifdef G2DEBUGOUTPUT
		sprintf(buf, "semprob is %d (life %d, alprob %d, min eyes %d, max eyes %d)\n", semprob, lf, alprob, min, max);
		outerr(buf);
#endif
		if (tm != G_COLOR(g1)) {
			outerr("Killing group.\n");
#ifdef G2DEBUGOUTPUT
			if (foughtalready(g1, TRYTOKILL,1-grcolor[g1],&movetree)) {
				outerr("Analysis cached.");
				if (TR_RESULT(movetree) >= V_WINLIKELY)
					outerr("Can kill.");
				else if (TR_RESULT(movetree) == V_WINKO)
					outerr("Can make ko.");
				else if (TR_RESULT(movetree) == V_UNKNOWNRES)
					outerr("Unknown result");
				else
					outerr("Can't kill.");
			}
#endif
			tmp = killmoves(g1);
			tmp2 = killsem(g1);
			i = 1;
			outerr("\nkillsem moves:\n");
			for (ptr = tmp2; ptr != EOL; ptr = link[ptr]) {
				sprintf(buf,"%s", ssqr(MV_MV(list[ptr]),buf2));
				i++;
				if (MV_MV(list[ptr]) == NOSQUARE)
					outerr("NOSQUARE generated");
				else if (MV_MV(list[ptr]) == PASS) {
					sprintf(buf2,"PASS: %d%%\n",100-MV_PROB(list[ptr])*2);
					outerr(buf2);
				}
				else {
					sprintf(buf2,"%s: %d%%\n",buf,100-MV_PROB(list[ptr])*2);
					outerr(buf2);
				}
			}
			killist(&tmp2);
		}
		else {
			outerr("Making life.\n");
#ifdef G2DEBUGOUTPUT
			if (foughtalready(g1,TRYTOLIVE,grcolor[g1],&movetree)) {
				outerr("Analysis cached.");
				if (TR_RESULT(movetree) >= V_WINLIKELY)
					outerr("Can live.");
				else if (TR_RESULT(movetree) == V_WINKO)
					outerr("Can make ko.");
				else if (TR_RESULT(movetree) == V_UNKNOWNRES)
					outerr("Unknown result");
				else
					outerr("Can't live.");
			}
#endif
			tmp = lifemoves(g1);
			if (G_ALIVE(g1) >= STRONG_SEMEAI && 
				G_ALIVE(g1) <= WEAK_POTENTIAL) {
				nbr = weaksemneighbors(grarmy[g1]);
				for (ptr = nbr; ptr != EOL; ptr = link[ptr])
					higroup((group_t)list[ptr]);
				if (nbr != EOL)
					outerr("Weak neighbors shown.\n");
				killist(&nbr);
			}
		}
	}
	else {
		outerr("Saving group in fight.\n");
		if (grcolor[g1] != tm)
			outerr("warning, wrong color to move\n");
#ifdef G2DEBUGOUTPUT
		eyes = eyesifcapture(S_ARMY(cursorpos), G_ARMY(g1), &maxeyes);
		sprintf(buf,"Winning probability: %d. Sem result: %d, eyesifcapture %d-%d\n",
			winsemprob(G_ARMY(g1),S_ARMY(cursorpos),0,0),
			semeai_result(G_ARMY(g1),S_ARMY(cursorpos)), eyes, maxeyes);
		outerr(buf);
		if (foughtalready(g1,S_GROUP(cursorpos),grcolor[g1],&movetree)) {
			outerr("Analysis cached.");
			if (TR_RESULT(movetree) >= V_WINLIKELY)
				outerr("Can live.");
			else if (TR_RESULT(movetree) == V_WINKO)
				outerr("Can make ko.");
			else if (TR_RESULT(movetree) == V_UNKNOWNRES)
				outerr("Unknown result");
			else
				outerr("Can't live.");
		}
#endif
		tmp = getsemeaimoves(g1,S_GROUP(cursorpos));
#ifdef G2DEBUGOUTPUT
		outerr("getsemeaimoves values:\n");
		for (i = 0; i < savesemmptr; ++i) {
			sprintf(buf,"%d %d+%d/8\n",savesemmoves[i],
			savesemval[i]/LIBVALUE,
			(savesemval[i]%LIBVALUE));
			outerr(buf);
		}
#endif
	}
	i = 1;
	outerr("\n");
	for (ptr = tmp; ptr != EOL; ptr = link[ptr]) {
		sprintf(buf,"%d",i);
		i++;
		if (MV_MV(list[ptr]) == NOSQUARE)
			outerr("NOSQUARE generated");
		else if (MV_MV(list[ptr]) == PASS) {
			sprintf(buf2,"PASS: %d%%\n",100-MV_PROB(list[ptr])*2);
			outerr(buf2);
		}
		else {
			outstone(MV_MV(list[ptr]),buf);
			sprintf(buf2,"%s: %d%%  %s\n",buf,100-MV_PROB(list[ptr])*2, ssqr(MV_MV(list[ptr]), buf3));
			outerr(buf2);
		}
	}
	killist(&tmp);
}

#endif  /* smallcode */


/* return list of (prob,move) to kill group g, which is in semeai 
 * may return an illegal ko capture
 */

static list_t killsem(group_t g) {
	list_t ptr,moves = EOL,tmp, weaknbrs;     
	int foundnbr = FALSE;
		/* find neighboring groups that all have to survive to win the fight */
	weaknbrs = weaksemneighbors(grarmy[g]);
	for (ptr = weaknbrs; ptr != EOL; ptr = link[ptr]) {
		tmp = getsemeaimoves(/*(group_t)list[armygroups[list[ptr]]] 3/04 */ (group_t)list[ptr],g);
		combinemoves(&tmp);	/* make sure only one of each move for this group pair */
 		mrglist(tmp,&moves);
 		killist(&tmp);
		foundnbr = TRUE;	/* added 7/03 */
 		}                   
 	if (!foundnbr) {  /* just attck the badgoup - no goodgroup */
  		tmp = getsemeaimoves(NOGROUP,g);
 		mrglist(tmp,&moves);
 		killist(&tmp);
 		}	
	killist(&weaknbrs);
	return(mincombinemoves(&moves));  /* fight with weakest neighbor determines result */
	}


           
/* what is the value of adding/removing eye potential in a semeai 
 * from/to a at point s.
 * army is attacking group.  p is potential.  s is proposed move.
 * com is common liberties between army and a.
 * army could be NOARMY!
 */           
           
static int poteyesemval(army_t army, army_t a, int p, sqr_t s, int com, int adding) {
	army_t a2;
	list_t ptr2;
	conn_t cn;
	int cval = 0,nlibs;
	int ep, color, libs;
	ep = (pots[p].pot_val+pots[p].pot_max)/2;
	if (s == armybestmove[a])
		ep = armybestpot[a];
	else if (s == armybestmove2[a])
		ep = armybestpot2[a];
	else if (pots[p].pot_type == BLOCK ||
		pots[p].pot_type == EXTEND)
		ep *= 4;
	if (pots[p].pot_type == CONNECT) {  /* cut */
		cn = pots[p].pot_where;
		libs = newconnlibs(a, cn, &a2);
		if (adding && libs + A_NUMLIBS(army) > A_NUMLIBS(a) + com + 3)
			libs = libs + A_NUMLIBS(army) > A_NUMLIBS(a) + com + 3;
		cval = LIBVALUE * libs;
/*		cval = LIBVALUE * (armylibs[a2] - comlist(armylbp[a],armylbp[a2])-1);  8/99 newconnlibs is more consistent */
/*		cval += LIBVALUE * armyrn_pot[a2]/2;  /* if can connect to group that can run */
		if (cnprot[cn] == CANT_CONNECT && cval > LIBVALUE)
			cval = LIBVALUE;  /* maybe the evaluation is wrong, so some incentive to play here */
		if (cnprot[cn] == MIGHT_CONNECT)
			cval /= 2;   /* not certain there is possible connection here */
		}
	else if (pots[p].pot_type == THREAT || pots[p].pot_type == POTTHREAT) {
		nlibs = 0;
		if (pots[p].pot_where == army)
			return LIBVALUE;  /* don't count pot eye for killing group fighting against */
		else {
			if (armynbp[pots[p].pot_where] == EOL)
				getarmynbp((army_t)pots[p].pot_where);
			for (ptr2 = armynbp[pots[p].pot_where];
		    	ptr2 != EOL; ptr2 = link[ptr2]) {
				if (list[ptr2] == a)continue;
				nlibs += armylibs[list[ptr2]] - 
					comlist(armylbp[list[ptr2]],a);
				cval += LIBVALUE * armyrn_pot[list[ptr2]];
				}
			}
		cval += LIBVALUE * (nlibs + armysize[pots[p].pot_where]);
		}
		
	if (armyeyespace[a] + ep >= 16 && !iskopoint(s, &color)) /* can live */
		cval += LIVELIBERTIES * LIBVALUE;
	else if (armyeyespace[a] < 8 && armyeyespace[a] + ep >= 8)
		cval += LIBVALUE * com;
	else if (armyeyespace[a] + ep > 10)
		cval += ep*LIBVALUE;	/* prevent threat to make life */
	else cval += ep*(LIBVALUE/8)*com;
	
	if (inlist(s,&armylbp[a]))  /* fills enemy liberty */
		cval += (lnbn[s] - comlist(nblbp[s],armylbp[a])) * LIBVALUE;
	if (!adding && army != NOARMY && inlist(s,&armylbp[army]))  /* fills own liberty */
		cval += (lnbn[s] - 1 - comlist(nblbp[s],armylbp[army])) * LIBVALUE;
	if (pots[p].pot_type == POTTHREAT)
		cval /= 2;
	return cval;
	}
	

/* attack group a in fight with army by removing group a's eye
 * potential. may return illegal ko capture
 * army could be NOARMY!
 */
 
 
static void semkillnbr(army_t army, army_t a, int val, int com) {
	sqr_t s;
	list_t tmplist,ptr,ptr2;
	int cval;
	int decay;  /* favor the best move for each eye remove */
	s = mvs[grpieces[list[armygroups[a]]]];
	for (ptr = armypot[a]; ptr != EOL; ptr = link[ptr]) {
		if (pots[list[ptr]].pot_max == 0 &&
			pots[list[ptr]].pot_type != THREAT &&
			pots[list[ptr]].pot_type != POTTHREAT &&
			pots[list[ptr]].pot_type != CONNECT)
			continue;
		tmplist = rmpot(a,list[ptr]);
		decay = 1;
		for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
			if ((sqr_t)list[ptr2] == NOSQUARE || 
				(sqr_t)list[ptr2] == PASS /* || (sqr_t)list[ptr2] == kosquare  1/1/99 allow generation of ko captures */)
				continue;
			cval = poteyesemval(army,a,list[ptr],list[ptr2],com, FALSE);
			if (cval > 0 && mptr < NUMSEMMOVES-1) {
				sem_val[mptr] = val + cval/decay;
				sem_moves[mptr] = list[ptr2];
				++mptr;
				decay++;
				}
			}
		killist(&tmplist);
		}
	}

static void addsemmove(sqr_t s, int val) {
	int i;
	for (i = 0; i < mptr; ++i) {
		if (sem_moves[i] == s) {
			sem_val[i] += val;
			return;
			}
		}
	if (mptr < NUMSEMMOVES-1) {
		sem_moves[mptr] = s;  
		sem_val[mptr] = val;
		++mptr;
		}
	}
                                                      
#ifdef NEVER                                                      
static void semrun(army_t a, int val) {
	int ptr, i;
	list_t moves, ptr2;
	for (i = 0; i < NUMRUN; ++i) {
		for (ptr = armyrun[a][i]; ptr != EOL; ptr = link[ptr]) {
			moves = runpoints(a,list[ptr],i);
			for (ptr2 = moves; ptr2 != EOL; ptr2 = link[ptr2])
				addsemmove(list[ptr2], val+LIBVALUE*semrunlibs[i]);	
			killist(&moves);
			}	
		}
	}
#endif

static void semrsurr(army_t a, int val) {
	int ptr, i;
	list_t moves, ptr2;
	for (i = 0; i < NUMRUN; ++i) {
		for (ptr = armyrun[a][i]; ptr != EOL; ptr = link[ptr]) {
			moves = surroundpoints(a,list[ptr]);
			for (ptr2 = moves; ptr2 != EOL; ptr2 = link[ptr2])
				addsemmove(list[ptr2], val+LIBVALUE*semrunlibs[i]);	
			killist(&moves);
			}	
		}
	}


/* measure value of move by how many liberties it leaves to go before
 * win fight.
 * kill opponent (a) by reducing his maximum liberties - value by how much
 * more min libs I have and how many liberties I take away.
 * return value of attacking this group by getting more liberties for myself.
 * army may be NOARMY!
 */

static void semkillsem(army_t army, army_t a, int val, int com, int atyp, int amax) {
	int ptr;
	if (armynbp[a] == EOL)getarmynbp(a);
	if (amax-atyp < 5 && army != NOARMY && !A_THREATENED(army))  /* have time to save another friendly group */
		for (ptr = armynbp[a]; ptr != EOL; ptr = link[ptr]) {
			if (list[ptr] == army)continue;
			if (A_ALIVE(list[ptr]) <= ALIVE)continue;
			if (armyrn_pot[list[ptr]] >= 6)continue;
			getmorelibs((army_t)list[ptr],a,0,FALSE);  /* get more liberties for other neighbors of a */
			}
	if (army == NOARMY || A_NUMLIBS(army) > 1)
		semkillnbr(army, a,val,com);  /* kill eyes of a*/
	filloutside(army,a,val);  /* fill liberties of a */
	semrsurr(a, val);  /* surround a */
	}


extern int extralibs(army_t a, sqr_t s);

/* count maximum new liberties obtained by move at s.  can also add move next
 * to s if can jump
 */

static int newlibcount(sqr_t s, army_t army, int val) {
	int lcount;  /* liberites I gain directly from moving here */
	int l2count;  /* number of ways to get even more liberties */
	list_t ptr2;
	int canjump = !S_NEUTRAL(s);	/* ok to jump since no enemy nearby */
	lcount = -1;
	l2count = 0;
	for (ptr2 = nblbp[s]; ptr2 != EOL; ptr2 = link[ptr2])
		if (lnbf[list[ptr2]][1-A_COLOR(army)] || edge[list[ptr2]] <= 1)
			canjump = FALSE;
	for (ptr2 = nblbp[s]; ptr2 != EOL; ptr2 = link[ptr2]) {
		if (lnbn[list[ptr2]] >= 3 && 
			lnbn[list[ptr2]] - comlist(nblbp[list[ptr2]],armylbp[army]) >= 2)
			l2count++;
		if (lnbn[list[ptr2]] == 4) {
		   lcount += 2;  /* access to more liberties */
		   if ((ld[s] >= 3 || canjump) && !S_NEUTRAL(s) && mptr < NUMSEMMOVES-1) {
				sem_moves[mptr] = list[ptr2];  /* jump */
				sem_val[mptr] = val+(4-comlist(nblbp[list[ptr2]],armylbp[army]))*LIBVALUE+ld[s]*(LIBVALUE/8);
				++mptr;
				/* lcount--; */
				}
			}
		else if (!inlist(list[ptr2],&armylbp[army]) && edge[list[ptr2]] > 1)
			++lcount;  /* new liberty */
		}
	if (l2count > 1)
		lcount += l2count-1;  /* 2 or more ways to get even one more liberty */	   
	lcount = extralibs(army, s);
	return(lcount);
	}
	
	
/* fill the outside liberties of a neighboring army (nbarmy) */
/* value by how much reduces his max libs */
/* army may be NOARMY */
static void filloutside(army_t army, army_t nbrarmy, int val)
{
	list_t ptr, ptr2, ptr3;
	sqr_t s, sn;
	int oflag, cancapture = FALSE, movecaptured, lcount;
	int nbr2libs = 0;	/* number of 2 liberty neighbors.  If only 1, liberty filling move is a sacrifice */
	int nbsize = 0;
	int makeko, cancap, kocapture;
	int color = 1 - A_COLOR(nbrarmy);
	oflag = FALSE;
	/* fill outside liberties */
	for (ptr = armylbp[nbrarmy]; ptr != EOL; ptr = link[ptr]) {
		s = list[ptr];
		if (army != NOARMY && inlist(s, &armylbp[army]))
			continue;  /* outside liberty only */
		/* no empty nbr point */
		if (lnbn[s] == 0) {
			for (ptr2 = nbgrp[s][color]; ptr2 != EOL; ptr2 = link[ptr2]) {
				/* friendly 2 liberty nbr, need to get more liberties before filling this liberty */
				if (grlibs[list[ptr2]] == 2) {
					nbr2libs++;
					nbsize = grsize[list[ptr2]];
					for (ptr3 = grlbp[list[ptr2]]; ptr3 != EOL; ptr3 = link[ptr3]) {
						sn = list[ptr3];
						if (sn == s) {
							continue;
						}
						if (mptr < NUMSEMMOVES-1) {
							sem_moves[mptr] = sn;  /* hope to get more liberties here */
							sem_val[mptr] = val + LIBVALUE / 2;
							++mptr;
						}
					}
					for (ptr3 = grnbp[list[ptr2]]; ptr3 != EOL; ptr3 = link[ptr3]) {
						if (G_ARMY(list[ptr3]) == nbrarmy || grlibs[list[ptr3]] > 1)
							continue;
						if (mptr < NUMSEMMOVES-1) {
							sem_moves[mptr] = list[grlbp[list[ptr3]]];  /* hope to get more liberties here */
							sem_val[mptr] = val + LIBVALUE / 2;
							++mptr;
						}
					}
				}
			}
		}
		movecaptured = FALSE;
		makeko = FALSE;
		kocapture = FALSE;
		if (lnbf[s][color] == 0 && lnbn[s] <= 1) {
			cancapture = FALSE;  /* can capture neighbor? */
			for (ptr3 = nbgrp[s][1 - color]; ptr3 != EOL; ptr3 = link[ptr3]) {
				if (grlibs[list[ptr3]] == 1) {
					cancapture = TRUE;
					if (grsize[list[ptr3]] == 1 && lnbn[s] == 0)
						kocapture = TRUE;
				}
				else for (ptr2 = grlbp[list[ptr3]]; ptr2 != EOL; ptr2 = link[ptr2]) {
					sn = list[ptr2];
					if (!inlist(sn, &armylbp[nbrarmy]) && mptr < NUMSEMMOVES-1) {
						sem_moves[mptr] = sn;  /* approach move */
						sem_val[mptr] = val + lnbn[s] * LIBVALUE - LIBVALUE / 2;
						++mptr;
					}
				}
			}
			if (lnbn[s] == 0 && !cancapture)
				continue;  /* illegal */
			movecaptured = TRUE;  /* immediate capture */
			if (lnbn[s] == 1 && 
				!inlist(list[nblbp[s]], &armylbp[nbrarmy]) && 
				mptr < NUMSEMMOVES - 1) {
				sn = list[nblbp[s]];
				sem_moves[mptr] = sn;
				sem_val[mptr] = val + lnbn[sn] * (LIBVALUE/8);
				++mptr;
				if (lnbn[sn] <= 2) {
					cancap = FALSE;
					for (ptr2 = nbgrp[sn][color]; ptr2 != EOL; ptr2 = link[ptr2]) {
						if (grlibs[list[ptr2]] == 1)
							cancap = TRUE;
					}
					makeko = !cancap;
				}
			}
		}
		lcount = newlibcount(s, nbrarmy, val);
		if (lnbn[s] <= 2 && lnbf[s][color] == 0 && !cancapture) {
			if (lnbn[s] <= 1)
				lcount -= 2;  /* prefer to play further away and let him get one liberty */
			else {
				lcount--;
				for (ptr2 = nblbp[s]; ptr2 != EOL; ptr2 = link[ptr2]) {
					if (lnbf[list[ptr2]][color] >= 2 && lnbf[list[ptr2]][A_COLOR(nbrarmy)] == 0) {
						lcount++;
						break;	/* my stone will be safe */
					}
				}
			}
		}
		sem_moves[mptr] = s;
		if (nbr2libs == 1 && nbsize > 1)
			sem_val[mptr] = val + 1;	/* don't sacrifice 3 or more stones to fill a liberty */
		else
			sem_val[mptr] = val + (lcount + 1) * LIBVALUE;
		if (makeko)
			sem_val[mptr] += LIBVALUE;
		else if (kocapture)
			sem_val[mptr] -= LIBVALUE / 2;
		else if (movecaptured)
			sem_val[mptr] -= LIBVALUE * 2;
		if (lnbf[s][color] != 0 && gralive[lgr[s]] != DEAD)
			sem_val[mptr] += LIBVALUE / 2;  /* play adjacent to friendly stone */
		if (mptr < NUMSEMMOVES-1)
			++mptr;
		oflag = TRUE;
	}

	/* fill a common liberty */
	for (ptr = armylbp[nbrarmy]; ptr != EOL; ptr = link[ptr]) {
		s = list[ptr];
		if (army != NOARMY && inlist(s, &armylbp[army])) {  /* inside/common liberties */
			if (mptr < NUMSEMMOVES - 1) {
				if (armylibs[army] == 2 && lnbn[s] == 0) {
					sem_moves[mptr] = PASS;
					sem_val[mptr] = LIBVALUE; /* try for seki.  opponent must fill own liberty */
				}
				else {
					sem_moves[mptr] = s;  
					if (A_ALIVE(nbrarmy) == SEKI)  /* prevent a nakade shape */
						sem_val[mptr] = val + LIBVALUE + lnbf[s][color];
					else
						/* add lnbn[s] to break ties */
						sem_val[mptr] = val + lnbn[s] + (lnbn[s] - comlist(nblbp[s], armylbp[nbrarmy]) - 1) * LIBVALUE;
				}
				++mptr;
			}
		}
	}
}


/* make an eye for army to win fight against a */

static void makaneye(army_t army, army_t a, int val, int com) {
	list_t ptr,tmplist,ptr2;
	int cval;

	for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
		if (pots[list[ptr]].pot_max == 0)continue;
		tmplist = adpot(army,list[ptr]);
		for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2]) {
			if ((sqr_t)list[ptr2] == NOSQUARE || 
				(sqr_t)list[ptr2] == PASS /* || (sqr_t)list[ptr2] == kosquare 1/1/99 allow ko recapture */)
				continue;
			cval = poteyesemval(a, army, list[ptr], list[ptr2], com, TRUE);
			if (cval > 0 && mptr < NUMSEMMOVES-1) {
				sem_val[mptr] = val + cval;
				sem_moves[mptr] = list[ptr2];
				++mptr;
				}
			}
		killist(&tmplist);
		}
	}


/* get more liberties for army so it can win the fight against a */

static void getmorelibs(army_t army, army_t a, int val, int atknbr) {
	list_t ptr,tmplist,ptr2,t2list = EOL;
	sqr_t s;
	int cval,cn,lcount,c,min,typ,max,memin,memax,hemin,hemax,amin,atyp,amax,ahemin,ahemax,amemin,amemax;
	army_t a2;

	/* connect for more libs */
	for (ptr = armypot[army]; ptr != EOL; ptr = link[ptr]) {
		if (pots[list[ptr]].pot_type != CONNECT)continue;
		cn = pots[list[ptr]].pot_where;
		a2 = grarmy[cngr1[cn]];
		if (a2 == army)a2 = grarmy[cngr2[cn]];
		cval = LIBVALUE * (armylibs[a2] - comlist(armylbp[army],armylbp[a2]) - 1);
		cpylist(armylbp[army],&t2list);		
		mrglist(armylbp[a2],&t2list);
		if (armyeyespace[army] < 8 && armyeyespace[a2] + armyeyespace[army] >= 8)
				cval += LIBVALUE * comlist(t2list,armylbp[a]);
		cval += LIBVALUE * armyrn_pot[a2]/2;  /* approximate */
		if (cnprot[cn] == CANT_CONNECT && cval > LIBVALUE)
			cval = LIBVALUE;
		else if (cnprot[cn] == MIGHT_CONNECT)
			cval /= 2;
		tmplist = adpot(army,list[ptr]);
		for (ptr2 = tmplist; ptr2 != EOL; ptr2 = link[ptr2])
				if (mptr < NUMSEMMOVES-1 /* && (sqr_t)list[ptr2] != kosquare 1/1/99 allow ko recapture */) {
					sem_moves[mptr] = list[ptr2];
					sem_val[mptr] = val+cval+LIBVALUE * 
						(lnbn[list[ptr2]] - comlist(nblbp[list[ptr2]],t2list) - 1);
					++mptr;
					}
		killist(&tmplist);
		killist(&t2list);
		}


	/* extend for more libs */
	c = A_COLOR(army);
	for (ptr = armylbp[army]; ptr != EOL; ptr = link[ptr]) {
		s = list[ptr];
		if (lnbn[s] <= 1)continue;
		lcount = lnbn[s] - 1 - comlist(nblbp[s], armylbp[army]);
		if (lcount > 0)
				if (mptr < NUMSEMMOVES-1) {
					sem_moves[mptr] = s;
					sem_val[mptr] = val+lcount*LIBVALUE;
					++mptr;
					}
		}
    /* attack neighboring group to kill it for more liberties */
    /* must bring his max liberties down below a's max liberties to kill it before a */
	semeailibs(a,&amin,&amax,&atyp,&ahemin,&ahemax,&amemin,&amemax);
    if (atknbr && amax-atyp <= 3) {  /* no urgent move against a */
    	if (armynbp[army] == EOL)
    		getarmynbp(army);
    	for (ptr = armynbp[army]; ptr != EOL; ptr = link[ptr]) {
    		if (list[ptr] == a)continue;
			semeailibs((army_t)list[ptr],&min,&max,&typ,&hemin,&hemax,&memin,&memax);
    		if (max < amax && typ < atyp &&
    			(A_ALIVE(list[ptr]) == SEMEAI || 
    			 A_ALIVE(list[ptr]) == WEAK_SEMEAI))
    			semkillsem(army,(army_t)list[ptr],val+(amax-max)*LIBVALUE,comlist(armylbp[army],armylbp[list[ptr]]),typ,max);
    		}
    	}
	}


